#! /usr/bin/env bash

## GLOBAL VARIABLES ##
args=$@
exit_code=0
tos=1 ## TIME TO SLEEP
all=0

chp="" # chapter
catid="" # categories id
level=0
result=Fail

declare -a excl_arr1
declare -a excl_arr2

## DECLARING THE DIRECTORIES ##
LOG_DIR="/var/log/centOS8_audit"
sub_logdir="$LOG_DIR/json_log"
debug_dir="/var/log/centOS8_audit/debug"
debug_file="centos_debug.log"
debug_dir="/var/log/centOS8_audit/debug"
JSN_DIR="json_file"
JSN_FIL="centOS8.json"
bannerfile="banner.txt"

		###	DISPLAY FEATURES      ###
function banner()
{
	cat ${bannerfile}

}

function write_info()
{
	if [ verbose ]; then
		echo "$(date -Ins) [INFO] $@" | tee -a "$debug_dir/$debug_file"
	else
		echo "$(date -Ins) [INFO] $@" >> "$debug_dir/$debug_file"
	fi
}

function write_debug()
{
	if [ verbose ]; then
		echo "$(date -Ins) [DEBUG] $@" | tee -a "$debug_dir/$debug_file"
	else
		echo "$(date -Ins) [DEBUG] $@" >> "$debug_dir/$debug_file" 
	fi
}

banner		#Display the banner function


		###	 MAIN	 ### 
write_info "Initiating....."
write_info "Audit Test Starting"

# 1.10 Ensure system-wide crypto policy is not legacy
crypto_policy_check_output=$(grep -E -i '^\s*LEGACY\s*(\s+#.*)?$' /etc/crypto-policies/config)
if [ -z "$crypto_policy_check_output" ]; then
    crypto_policy_check_result="Pass"
else
    crypto_policy_check_result="Fail"
fi

# 1.1.1.1 Ensure mounting of cramfs filesystems is disabled
modprobe_check_output=$(modprobe -n -v cramfs | grep "^install")
lsmod_check_output=$(lsmod | grep "^cramfs\s")
blacklist_check_output=$(grep -E "^blacklist\s+cramfs" /etc/modprobe.d/*)

if [ -z "$lsmod_check_output" ] && [ "$modprobe_check_output" == *"install /bin/false"* ] && [ -n "$blacklist_check_output" ]; then
    cramfs_check_result="Pass"
else
    cramfs_check_result="Fail"
fi

# 1.1.2.1 Ensure /tmp is a separate partition
# Check if /tmp is mounted
findmnt_output=$(findmnt --kernel /tmp)

# Check if systemd will mount /tmp at boot time
systemctl_output=$(systemctl is-enabled tmp.mount)

# Check if /tmp is mounted and systemd will mount it at boot time
if echo "$findmnt_output" | grep -q "/tmp"; then
    tmp_mounted="Yes"
else
    tmp_mounted="No"
fi

if [ "$systemctl_output" = "static" ] || [ "$systemctl_output" = "generated" ]; then
    tmp_boot_enabled="Yes"
else
    tmp_boot_enabled="No"
fi


# Check if the conditions are met
if [ "$tmp_mounted" = "Yes" ] && [ "$tmp_boot_enabled" = "Yes" ]; then
    tmp_separated_partition_result="Pass"
else
    tmp_separated_partition_result="Fail"
fi

#1.1.2.2 Ensure nodev option set on /tmp partition
# Check if the nodev option is set for /tmp mount
nodev_findmnt_output=$(findmnt --kernel /tmp | grep nodev)

# Check if nodev option is set for /tmp mount
if echo "$nodev_findmnt_output" | grep -q "nodev"; then
    nodev_option_set="Yes"
else
    nodev_option_set="No"
fi

# Check if the condition is met
if [ "$nodev_option_set" = "Yes" ]; then
    tmp_partition_nodev_result="Pass"
else
    tmp_partition_nodev_result="Fail"
fi

# 1.1.2.3 Ensure noexec option set on /tmp partition
# Check if the noexec option is set for /tmp mount
noexec_findmnt_output=$(findmnt --kernel /tmp | grep noexec)

# Check if noexec option is set for /tmp mount
if echo "$noexec_findmnt_output" | grep -q "noexec"; then
    noexec_option_set="Yes"
else
    noexec_option_set="No"
fi

# Check if the condition is met
if [ "$noexec_option_set" = "Yes" ]; then
    tmp_partition_noexec_result="Pass"
else
    tmp_partition_noexec_result="Fail"
fi

# 1.1.2.4 Ensure nosuid option set on /tmp partition
# Check if the nosuid option is set for /tmp mount
nosuid_findmnt_output=$(findmnt --kernel /tmp | grep nosuid)

# Check if nosuid option is set for /tmp mount
if echo "$nosuid_findmnt_output" | grep -q "nosuid"; then
    nosuid_option_set="Yes"
else
    nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$nosuid_option_set" = "Yes" ]; then
    tmp_partition_nosuid_result="Pass"
else
    tmp_partition_nosuid_result="Fail"
fi

# 1.1.3.2 Ensure nodev option set on /var partition
# Check if the nodev option is set for /var mount
var_nodev_findmnt_output=$(findmnt --kernel /var | grep nodev)

# Check if nodev option is set for /var mount
if echo "$var_nodev_findmnt_output" | grep -q "nodev"; then
    var_nodev_option_set="Yes"
else
    var_nodev_option_set="No"
fi

# Output the result
echo "Is nodev option set for /var mount: $nodev_option_set"

# Check if the condition is met
if [ "$var_nodev_option_set" = "Yes" ]; then
    var_nodev_result="Pass"
else
    var_nodev_result="Fail"
fi

# 1.1.3.3 Ensure noexec option set on /var partition
# Check if the noexec option is set for /var mount
var_noexec_findmnt_output=$(findmnt --kernel /var | grep noexec)

# Check if noexec option is set for /var mount
if echo "$var_noexec_findmnt_output" | grep -q "noexec"; then
    var_noexec_option_set="Yes"
else
    var_noexec_option_set="No"
fi

# Output the result
echo "Is noexec option set for /var mount: $noexec_option_set"

# Check if the condition is met
if [ "$var_noexec_option_set" = "Yes" ]; then
    var_noexec_result="Pass"
else
    var_noexec_result="Fail"
fi

# 1.1.3.4 Ensure nosuid option set on /var partition
# Check if the nosuid option is set for /var mount
var_nosuid_findmnt_output=$(findmnt --kernel /var | grep nosuid)

# Check if nosuid option is set for /var mount
if echo "$var_nosuid_findmnt_output" | grep -q "nosuid"; then
    var_nosuid_option_set="Yes"
else
    var_nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$var_nosuid_option_set" = "Yes" ]; then
    var_nosuid_result="Pass"
else
    var_nosuid_result="Fail"
fi

# 1.1.4.2 Ensure noexec option set on /var/tmp partition
# Check if the noexec option is set for /var/tmp mount
var_tmp_noexec_findmnt_output=$(findmnt --kernel /var/tmp | grep noexec)

# Check if noexec option is set for /var/tmp mount
if echo "$var_tmp_noexec_findmnt_output" | grep -q "noexec"; then
    var_tmp_noexec_option_set="Yes"
else
    var_tmp_noexec_option_set="No"
fi

# Check if the condition is met
if [ "$var_tmp_noexec_option_set" = "Yes" ]; then
    var_tmp_noexec_result="Pass"
else
    var_tmp_noexec_result="Fail"
fi

# 1.1.4.3 Ensure nosuid option set on /var/tmp partition
# Check if the nosuid option is set for /var/tmp mount
var_tmp_nosuid_findmnt_output=$(findmnt --kernel /var/tmp | grep nosuid)

# Check if nosuid option is set for /var/tmp mount
if echo "$var_tmp_nosuid_findmnt_output" | grep -q "nosuid"; then
    var_tmp_nosuid_option_set="Yes"
else
    var_tmp_nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$var_tmp_nosuid_option_set" = "Yes" ]; then
    var_tmp_nosuid_result="Pass"
else
    var_tmp_nosuid_result="Fail"
fi

# 1.1.4.4 Ensure nodev option set on /var/tmp partition
# Check if the nodev option is set for /var/tmp mount
var_tmp_nodev_findmnt_output=$(findmnt --kernel /var/tmp | grep nodev)

# Check if nodev option is set for /var/tmp mount
if echo "$var_tmp_nodev_findmnt_output" | grep -q "nodev"; then
    var_tmp_nodev_option_set="Yes"
else
    var_tmp_nodev_option_set="No"
fi

# Check if the condition is met
if [ "$var_tmp_nodev_option_set" = "Yes" ]; then
    var_tmp_nodev_result="Pass"
else
    var_tmp_nodev_result="Fail"
fi

# 1.1.5.2 Ensure nodev option set on /var/log partition
# Check if the nodev option is set for /var/log mount
var_log_findmnt_output=$(findmnt --kernel /var/log | grep nodev)

# Check if nodev option is set for /var/log mount
if echo "$var_log_findmnt_output" | grep -q "nodev"; then
    var_log_nodev_option_set="Yes"
else
    var_log_nodev_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_nodev_option_set" = "Yes" ]; then
    var_log_nodev_result="Pass"
else
    var_log_nodev_result="Fail"
fi

# 1.1.5.3 Ensure noexec option set on /var/log partition
# Check if the noexec option is set for /var/log mount
var_log_findmnt_output=$(findmnt --kernel /var/log | grep noexec)

# Check if noexec option is set for /var/log mount
if echo "$var_log_findmnt_output" | grep -q "noexec"; then
    var_log_noexec_option_set="Yes"
else
    var_log_noexec_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_noexec_option_set" = "Yes" ]; then
    var_log_noexec_result="Pass"
else
    var_log_noexec_result="Fail"
fi

# 1.1.5.4 Ensure nosuid option set on /var/log partition
# Check if the nosuid option is set for /var/log mount
var_log_nosuid_findmnt_output=$(findmnt --kernel /var/log | grep nosuid)

# Check if nosuid option is set for /var/log mount
if echo "$var_log_nosuid_findmnt_output" | grep -q "nosuid"; then
    var_log_nosuid_option_set="Yes"
else
    var_log_nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_nosuid_option_set" = "Yes" ]; then
    var_log_nosuid_result="Pass"
else
    var_log_nosuid_result="Fail"
fi

# 1.1.6.2 Ensure noexec option set on /var/log/audit partition
# Check if the noexec option is set for /var/log/audit mount
var_log_audit_noexec_findmnt_output=$(findmnt --kernel /var/log/audit | grep noexec)

# Check if noexec option is set for /var/log/audit mount
if echo "$var_log_audit_noexec_findmnt_output" | grep -q "noexec"; then
    var_log_audit_noexec_option_set="Yes"
else
    var_log_audit_noexec_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_audit_noexec_option_set" = "Yes" ]; then
    var_log_audit_result="Pass"
else
    var_log_audit_result="Fail"
fi

# 1.1.6.3 Ensure nodev option set on /var/log/audit partition
# Check if the nodev option is set for /var/log/audit mount
var_log_audit_nodev_findmnt_output=$(findmnt --kernel /var/log/audit | grep nodev)

# Check if nodev option is set for /var/log/audit mount
if echo "$var_log_audit_findmnt_output" | grep -q "nodev"; then
    var_log_audit_nodev_option_set="Yes"
else
    var_log_audit_nodev_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_audit_nodev_option_set" = "Yes" ]; then
    var_log_audit_nodev_result="Pass"
else
    var_log_audit_nodev_result="Fail"
fi

# 1.1.6.4 Ensure nosuid option set on /var/log/audit partition
# Check if the nosuid option is set for /var/log/audit mount
var_log_audit_nosuid_findmnt_output=$(findmnt --kernel /var/log/audit | grep nosuid)

# Check if nosuid option is set for /var/log/audit mount
if echo "$var_log_audit_nosuid_findmnt_output" | grep -q "nosuid"; then
    var_log_audit_nosuid_option_set="Yes"
else
    var_log_audit_nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$var_log_audit_nosuid_option_set" = "Yes" ]; then
    var_log_audit_nosuid_result="Pass"
else
    var_log_audit_nosuid_result="Fail"
fi

# 1.1.7.2 Ensure nodev option set on /home partition
# Check if the nodev option is set for /home mount
home_nodev_findmnt_output=$(findmnt --kernel /home | grep nodev)

# Check if nodev option is set for /home mount
if echo "$home_nodev_findmnt_output" | grep -q "nodev"; then
    home_nodev_option_set="Yes"
else
    home_nodev_option_set="No"
fi

# Check if the condition is met
if [ "$home_nodev_option_set" = "Yes" ]; then
    home_nodev_result="Pass"
else
    home_nodev_result="Fail"
fi

# 1.1.7.3 Ensure nosuid option set on /home partition
# Check if the nosuid option is set for /home mount
home_nosuid_findmnt_output=$(findmnt --kernel /home | grep nosuid)

# Check if nosuid option is set for /home mount
if echo "$home_nosuid_findmnt_output" | grep -q "nosuid"; then
    home_nosuid_option_set="Yes"
else
    home_nosuid_option_set="No"
fi

# Check if the condition is met
if [ "$home_nosuid_option_set" = "Yes" ]; then
    home_nosuid_result="Pass"
else
    home_suid_result="Fail"
fi

# 1.1.7.4 Ensure usrquota option set on /home partition
# Check if the usrquota option is set for /home mount
home_usrquota_findmnt_output=$(findmnt --kernel /home | grep usrquota)

# Check if usrquota option is set for /home mount
if echo "$home_usrquota_findmnt_output" | grep -q "usrquota"; then
    home_usrquota_option_set="Yes"
else
    home_usrquota_option_set="No"
fi

# Check if quotas are enabled for /home
home_quotaon_output=$(quotaon -p /home | grep user)

# Check if user quotas are enabled for /home
if echo "$home_quotaon_output" | grep -q "user quota on /home"; then
    home_user_quotas_enabled="Yes"
else
    home_user_quotas_enabled="No"
fi

# Check if the conditions are met
if [ "$home_usrquota_option_set" = "Yes" ] && [ "$home_user_quotas_enabled" = "Yes" ]; then
    home_usrquota_result="Pass"
else
    home_usrquota_result="Fail"
fi

# 1.1.7.5 Ensure grpquota option set on /home partition
# Check if the grpquota option is set for /home mount
home_grpquota_findmnt_output=$(findmnt --kernel /home | grep grpquota)
echo "findmnt --kernel /home output:"
echo "$findmnt_output"

# Check if grpquota option is set for /home mount
if echo "$home_grpquota_findmnt_output" | grep -q "grpquota"; then
    home_grpquota_option_set="Yes"
else
    home_grpquota_option_set="No"
fi

# Check if quotas are enabled for /home
home_grp_quotaon_output=$(quotaon -p /home | grep group)

# Check if group quotas are enabled for /home
if echo "$home_grp_quotaon_output" | grep -q "group quota on /home"; then
    home_group_quotas_enabled="Yes"
else
    home_group_quotas_enabled="No"
fi

# Check if the conditions are met
if [ "$home_grpquota_option_set" = "Yes" ] && [ "$home_group_quotas_enabled" = "Yes" ]; then
    home_grpquota_result="Pass"
else
    result="Fail"
fi

# 1.1.8.1 Ensure nodev option set on /dev/shm partition
# Check if /dev/shm is mounted and if so, verify the nodev option
dev_shm_nodev_mount_output=$(mount | grep -E '\s/dev/shm\s' | grep -v nodev)

# Check if the output is empty
if [ -z "$dev_shm_nodev_mount_output" ]; then
    dev_shm_nodev_result="Pass"
else
    dev_shm_nodev_result="Fail"
fi

# 1.1.8.2 Ensure noexec option set on /dev/shm partition
# Check if the noexec option is set for /dev/shm mount
dev_shm_noexec_findmnt_output=$(findmnt --kernel /dev/shm | grep noexec)

# Check if noexec option is set for /dev/shm mount
if echo "$dev_shm_noexec_findmnt_output" | grep -q "noexec"; then
    dev_shm_noexec_option_set="Yes"
else
    dev_shm_noexec_option_set="No"
fi

# Check if the condition is met
if [ "$dev_shm_noexec_option_set" = "Yes" ]; then
    dev_shm_noexec_result="Pass"
else
    dev_shm_noexec_result="Fail"
fi

# 1.1.8.3 Ensure nosuid option set on /dev/shm partition
# Check if /dev/shm is mounted and if so, verify the nosuid option
dev_shm_nosuid_mount_output=$(mount | grep -E '\s/dev/shm\s' | grep -v nosuid)
echo "mount | grep -E '\s/dev/shm\s' | grep -v nosuid output:"
echo "$mount_output"

# Check if the output is empty
if [ -z "$dev_shm_nosuid_mount_output" ]; then
    dev_shm_nosuid_result="Pass"
else
    dev_shm_nosuid_result="Fail"
fi

# 1.2.2 Ensure gpgcheck is globally activated
# Verify gpgcheck setting in global configuration file
global_gpgcheck=$(grep ^gpgcheck /etc/dnf/dnf.conf | awk -F '=' '{print $2}' | tr -d ' ')
echo "Global gpgcheck setting: $global_gpgcheck"

# Verify gpgcheck setting in repository configuration files
invalid_gpgcheck_entries=$(grep -P \"^gpgcheck\h*=\h*[^1].*\h*$\" /etc/yum.repos.d/*)
echo "Invalid gpgcheck entries in repository configuration files:"
echo "$invalid_gpgcheck_entries"

# Check if both global and repository configurations are compliant
if [ "$global_gpgcheck" = "1" ] && [ -z "$invalid_gpgcheck_entries" ]; then
    gpgcheck_result="Pass"
else
    gpgcheck_result="Fail"
fi

# 1.3.1 Ensure AIDE is installed
# Verify if AIDE is installed
aide_installed=$(rpm -q aide)

# Check if AIDE is installed
if [ "$aide_installed" ]; then
    aide_result="Pass"
else
    aide_result="Fail"
fi

# 1.3.2 Ensure filesystem integrity is regularly checked
# Check for AIDE cron job
aide_cron_job=$(grep -Ers '^([^#]+\s+)?(\/usr\/s?bin\/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' /etc/cron.* /etc/crontab /var/spool/cron/)

# Check if aidcheck.service is enabled
aide_service_enabled=$(systemctl is-enabled aidcheck.service)

# Check if aidcheck.timer is enabled
aide_timer_enabled=$(systemctl is-enabled aidcheck.timer)

# Check if aidcheck.timer is running
aide_timer_status=$(systemctl status aidcheck.timer)

# Check if a cron job or timer/service is in compliance with the site policy
if [ -n "$aide_cron_job" ] || [ "$aide_service_enabled" = "enabled" ] && [ "$aide_timer_enabled" = "enabled" ] && [[ "$aide_timer_status" == *"Active: active"* ]]; then
    filesystem_integrity_result="Pass"
else
    filesystem_integrity_result="Fail"
fi

# 1.4.1 Ensure bootloader password is set
{
    tst1="" tst2="" output=""
    grubdir=$(dirname "$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -El '^\s*(kernelopts=|linux|kernel)' {} \;)")
    
    if [ -f "$grubdir/user.cfg" ]; then
        grep -Pq '^\h*GRUB2_PASSWORD\h*=\h*.+$' "$grubdir/user.cfg" && output="bootloader password set in \"$grubdir/user.cfg\""
    fi
    
    if [ -z "$output" ]; then
        grep -Piq '^\h*set\h+superusers\h*=\h*""?[^""\n\r]+""?(\h+.*)?$' "$grubdir/grub.cfg" && tst1=pass
        grep -Piq '^\h*password(_pbkdf2)?\h+\H+\h+.+$' "$grubdir/grub.cfg" && tst2=pass
        if [ "$tst1" = pass ] && [ "$tst2" = pass ]; then
            bootloader_passwd_set="Pass"
        else
            bootloader_passwd_set="Fail"
        fi
    fi
}

# 1.4.2 Ensure permissions on bootloader config are configured
{
    boootloader_perm_output=""
    boootloader_perm_output2=""
    boootloader_perm_output3=""
    boootloader_perm_output4=""

    # Find the directory containing grub files
    grubdir=$(dirname "$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl '^\h*(kernelopts=|linux|kernel)' {} \;)")

    # Iterate over each grub file
    for grubfile in $grubdir/user.cfg $grubdir/grubenv $grubdir/grub.cfg; do
        if [ -f "$grubfile" ]; then
            # Check permissions
            if stat -c "%a" "$grubfile" | grep -Pq '^\h*[0-7]00$'; then
                boootloader_perm_output="$boootloader_perm_output\npermissions on \"$grubfile\" are \"$(stat -c "%a" "$grubfile")\""
            else
                boootloader_perm_output3="$boootloader_perm_output3\npermissions on \"$grubfile\" are \"$(stat -c "%a" "$grubfile")\""
            fi
            # Check ownership and group
            if stat -c "%u:%g" "$grubfile" | grep -Pq '^\h*0:0$'; then
                boootloader_perm_output2="$boootloader_perm_output2\n\"$grubfile\" is owned by \"$(stat -c "%U" "$grubfile")\" and belongs to group \"$(stat -c "%G" "$grubfile")\""
            else
                boootloader_perm_output4="$boootloader_perm_output4\n\"$grubfile\" is owned by \"$(stat -c "%U" "$grubfile")\" and belongs to group \"$(stat -c "%G" "$grubfile")\""
            fi
        fi
    done

    # Check if all outputs are empty or not
    if [[ -n "$boootloader_perm_output" && -n "$boootloader_perm_output2" && -z "$boootloader_perm_output3" && -z "$boootloader_perm_output4" ]]; then
        bootloader_permission_config_result="Pass"
    else
        bootloader_permission_config_result="Fail"
    fi
}

# 1.4.3 Ensure authentication is required when booting into rescue mode
# Run the command and store the result in a variable
auth_booting_in_rescue_mode=$(grep -r '/systemd-sulogin-shell' /usr/lib/systemd/system/rescue.service /etc/systemd/system/rescue.service.d)

# Check if the result contains the expected line
if [[ $auth_booting_in_rescue_mode == *"ExecStart=-/usr/lib/systemd/systemd-sulogin-shell rescue"* ]]; then
    auth_booting_in_rescue_mode_result="Pass"
else
    auth_booting_in_rescue_mode_result="Fail"
fi

# 1.5.1 Ensure core dump storage is disabled
# Run the command and store the result in a variable
core_dump_storage_output=$(grep -i '^\s*storage\s*=\s*none' /etc/systemd/coredump.conf)

# Check if the result contains the expected line
if [[ "$core_dump_storage_output" == "Storage=none" ]]; then
    core_dump_storage_result="Pass"
else
    core_dump_storage_result="Fail"
fi

# 1.5.2 Ensure core dump backtraces are disabled
# Run the command and store the result in a variable
core_dump_backtraces_output=$(grep -i '^\s*ProcessSizeMax\s*=\s*0' /etc/systemd/coredump.conf)

# Check if the result contains the expected line
if [[ "$core_dump_backtraces_output" == "ProcessSizeMax=0" ]]; then
    core_dump_backtraces_result="Pass"
else
    core_dump_backtraces_result="Fail"
fi

# 1.5.3 Ensure address space layout randomization (ASLR) is enabled
{
    krp=""
    pafile=""
    fafile=""
    kpname="kernel.randomize_va_space"
    kpvalue="2"
    searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    
    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"
    
    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then       
	aslr_result="Pass"	
	aslr_message="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        aslr_result="Fail"
    	[ "$krp" != "$kpvalue" ] && aslr_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
    	[ -n "$fafile" ] && aslr_message+="  \"$kpname\" is set incorrectly in \"$fafile\""
    	[ -z "$pafile" ] && aslr_message+="  \"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    fi
}

# 1.6.1.1 Ensure SELinux is installed
# Run the command to check if SELinux is installed
SeLinux_rpm_output=$(rpm -q libselinux)

# Check if the output contains "libselinux" indicating SELinux is installed
if [[ "$SeLinux_rpm_output" == *"libselinux"* ]]; then
    echo "SELinux is installed."
    SELinux_rpm_result="Pass"
else
    echo "SELinux is not installed."
    SELinux_rpm_result="Fail"
fi

# 1.6.1.2 Ensure SELinux is not disabled in bootloader configuration
# Run the command to check if selinux=0 or enforcing=0 parameters are set
SElinux_not_disabled_bootloader_config_grep_output=$(grep -P -- '^\h*(kernelopts=|linux|kernel)' $(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;) | grep -E -- '(selinux=0|enforcing=0)')

# Check if anything is returned
if [ -z "$SElinux_not_disabled_bootloader_config_grep_output" ]; then
    SElinux_not_disabled_bootloader_config_message="Pass: Neither selinux=0 nor enforcing=0 parameters are set."
    SElinux_not_disabled_bootloader_config_result="Pass"
else
    SElinux_not_disabled_bootloader_config_message="Fail: selinux=0 or enforcing=0 parameters are set."
    SElinux_not_disabled_bootloader_config_result="Fail"
fi

# 1.6.1.3 Ensure SELinux policy is configured
# Check /etc/selinux/config file
seLinux_policy_config_output=$(grep -E '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config)

# Check SELinux status
seLinux_policy_sestatus_output=$(sestatus | grep "Loaded policy name")

# Check if output matches "targeted" or "mls" in both cases
if [[ "$seLinux_policy_config_output" == *"targeted"* || "$seLinux_policy_config_outputseLinux_policy_config_output" == *"mls"* ]]; then
    if [[ "$seLinux_policy_sestatus_output" == *"targeted"* || "$seLinux_policy_sestatus_output" == *"mls"* ]]; then
        seLinux_policy_message="Pass: SELinux type is either 'targeted' or 'mls'."
        seLinux_policy_result="Pass"
    else
        seLinux_policy_message="Fail: SELinux type is not 'targeted' or 'mls' according to sestatus."
        seLinux_policy_result="Fail"
    fi
else
    seLinux_policy_message="Fail: SELinux type is not 'targeted' or 'mls' in /etc/selinux/config."
    seLinux_policy_result="Fail"
fi

# 1.6.1.4 Ensure the SELinux mode is not disabled
# Verify SELinux's current mode
seLinux_current_mode=$(getenforce)

# Verify SELinux's configured mode
seLinux_configured_mode=$(grep -Ei '^\s*SELINUX=(enforcing|permissive)' /etc/selinux/config)

# Check if current mode matches configured mode
if [[ "$seLinux_current_mode" == "Enforcing" && "$seLinux_configured_mode" == *"enforcing"* ]]; then
    seLinux_configured_message="Pass: SELinux is currently enforcing and configured to be enforcing."
    seLinux_configured_result="Pass"
elif [[ "$seLinux_current_mode" == "Permissive" && "$seLinux_configured_mode" == *"permissive"* ]]; then
    seLinux_configured_message="Pass: SELinux is currently permissive and configured to be permissive."
    seLinux_configured_result="Pass"
else
    seLinux_configured_message="Fail: SELinux is not in the expected mode or configured incorrectly."
    seLinux_configured_result="Fail"
fi

# 1.6.1.6 Ensure no unconfined services exist
# Run the command and check its output
no_confined_services_output=$(ps -eZ | grep unconfined_service_t)

# Check if output is empty
if [ -z "$no_confined_services_output" ]; then
    no_confined_services_message="Pass: No processes with unconfined_service_t label found."
    no_confined_services_result="Pass"
else
    no_confined_services_message="Fail: Processes with unconfined_service_t label found."
    no_confined_services_result="Fail"
fi

# 1.6.1.8 Ensure the MCS Translation Service (mcstrans) is not installed
# Run the command and check its output
mcstrans_output=$(rpm -q mcstrans)

# Check if output indicates mcstrans is not installed
if [[ "$mcstrans_output" == *"not installed"* ]]; then
    mcstrans_message="Pass: mcstrans is not installed."
    mcstrans_result="Pass"
else
    mcstrans_message="Fail: mcstrans is installed."
    mcstrans_result="Fail"
fi

# 1.7.1 Ensure message of the day is configured properly
# Check the content of /etc/motd
motd_content=$(cat /etc/motd)

# Check for specific characters and OS release ID in /etc/motd
motd_content_grep_result=$(grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/""//g'))" /etc/motd)

# Check if the grep result is empty
if [ -z "$motd_content_grep_result" ]; then
    motd_message="Pass: /etc/motd content matches site policy and does not contain specific characters."
    motd_result="Pass"
else
    motd_message="Fail: /etc/motd content does not match site policy or contains specific characters."
    motd_result="Fail"
fi

# 1.7.2 Ensure local login warning banner is configured properly
# Check the content of /etc/issue
issue_content=$(cat /etc/issue)

# Check for specific characters and OS release ID in /etc/issue
issue_content_grep_result=$(grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/""//g'))" /etc/issue)

# Check if the grep result is empty
if [ -z "$issue_content_grep_result" ]; then
    issue_content_message="Pass: /etc/issue content matches site policy and does not contain specific characters."
    issue_content_result="Pass"
else
    issue_content_message="Fail: /etc/issue content does not match site policy or contains specific characters."
    issue_content_result="Fail"
fi

# 1.7.3 Ensure remote login warning banner is configured properly
# Check the content of /etc/issue.net
remote_login_warning_issue_net_content=$(cat /etc/issue.net)

# Check for specific characters and OS release ID in /etc/issue.net
remote_login_warning_grep_result=$(grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/""//g'))" /etc/issue.net)

# Check if the grep result is empty
if [ -z "$remote_login_warning_grep_result" ]; then
    remote_login_warning_message="Pass: /etc/issue.net content matches site policy and does not contain specific characters."
    remote_login_warning_result="Pass"
else
    remote_login_warning_message="Fail: /etc/issue.net content does not match site policy or contains specific characters."
    remote_login_warning_result="Fail"
fi

# 1.7.4 Ensure permissions on /etc/motd are configured
# Run the stat command to get information about /etc/motd
etc_motd_stat_output=$(stat /etc/motd)

# Extract the permissions, Uid, and Gid from the stat output
etc_motd_permissions=$(stat /etc/motd | grep Access | grep Uid)
echo "$etc_motd_permissions"

# Check if the permissions, Uid, and Gid match the expected values
if [[ "$etc_motd_permissions" == "Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)" ]]; then
    etc_motd_message="Pass: Permissions, Uid, and Gid for /etc/motd are correct."
    etc_motd_result="Pass"
else
    etc_motd_message="Fail: Permissions, Uid, or Gid for /etc/motd are incorrect."
    etc_motd_result="Fail"
fi

# 1.7.5 Ensure permissions on /etc/issue are configured
# Run the stat command to get information about /etc/issue
etc_issue_stat_output=$(stat /etc/issue)

# Extract the permissions, Uid, and Gid from the stat output
etc_issue_permissions=$(stat /etc/issue | grep Access | grep Uid)

# Check if the permissions, Uid, and Gid match the expected values
if [[ "$etc_issue_permissions" == "Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)" ]]; then
    etc_issue_message="Pass: Permissions, Uid, and Gid for /etc/motd are correct."
    etc_issue_result="Pass"
else
    etc_issue_message="Fail: Permissions, Uid, or Gid for /etc/motd are incorrect."
    etc_issue_result="Fail"
fi

# 1.7.6 Ensure permissions on /etc/issue.net are configured
# Run the stat command to get information about /etc/issue.net
etc_issueNet_stat_output=$(stat /etc/issue.net)

# Extract the permissions, Uid, and Gid from the stat output
etc_issueNet_permissions=$(stat /etc/issue.net | grep Access | grep Uid)

# Check if the permissions, Uid, and Gid match the expected values
if [[ "$etc_issueNet_permissions" == "Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)" ]]; then
    etc_issueNet_message="Pass: Permissions, Uid, and Gid for /etc/motd are correct."
    etc_issueNet_result="Pass"
else
    etc_issueNet_message="Fail: Permissions, Uid, or Gid for /etc/motd are incorrect."
    etc_issueNet_result="Fail"
fi

# 1.8.2 Ensure GDM login banner is configured
# Verify the existence and contents of /etc/dconf/profile/gdm
if [ -f "/etc/dconf/profile/gdm" ]; then
    gdm_profile_contents=$(<"/etc/dconf/profile/gdm")
    if [[ "$gdm_profile_contents" == *"user-db:user"* && "$gdm_profile_contents" == *"system-db:gdm"* && "$gdm_profile_contents" == *"file-db:/usr/share/gdm/greeter-dconf-defaults"* ]]; then
        gdm_profile_message="Pass: /etc/dconf/profile/gdm exists and has the correct contents."
        gdm_profile_result="Pass"
    else
        gdm_profile_message="Fail: /etc/dconf/profile/gdm exists but does not have the correct contents."
        gdm_profile_result="Fail"
    fi
else
    gdm_profile_message="Fail: /etc/dconf/profile/gdm does not exist."
    gdm_profile_result="Fail"
fi

# Verify the existence and contents of a file in /etc/dconf/db/gdm.d/
login_banner_gdm_file="/etc/dconf/db/gdm.d/01-banner-message"
if [ -f "$login_banner_gdm_file" ]; then
    gdm_contents=$(<"$login_banner_gdm_file")
    if [[ "$gdm_contents" == *"[org/gnome/login-screen]"* && "$gdm_contents" == *"banner-message-enable=true"* ]]; then
        gdm_message="Pass: $login_banner_gdm_file exists and has the correct structure."
        # Check if the banner message exists and contains some content
        if [[ "$gdm_contents" == *"banner-message-text="* ]]; then
            gdm_message=+"  Pass: Banner message is configured."
            gdm_result="Pass"
        else
            gdm_message=+"  Fail: Banner message is not configured."
            gdm_result="Fail"
        fi
    else
        gdm_message="Fail: $login_banner_gdm_file exists but does not have the correct structure."
        gdm_result="Fail"
    fi
else
    gdm_message="Fail: $login_banner_gdm_file does not exist."
    gdm_result="Fail"
fi

# Output the overall result
if [ "$gdm_profile_result" == "Pass" ] && [ "$gdm_result" == "Pass" ]; then
    gdm_overall_result="Pass"
else
    gdm_overall_result="Fail"
fi

# 1.8.3 Ensure last logged in user display is disabled
# Verify the existence and contents of /etc/dconf/profile/gdm
if [ -f "/etc/dconf/profile/gdm" ]; then
    profile_contents=$(<"/etc/dconf/profile/gdm")
    if [[ "$profile_contents" == *"user-db:user"* && "$profile_contents" == *"system-db:gdm"* && "$profile_contents" == *"file-db:/usr/share/gdm/greeter-dconf-defaults"* ]]; then
        profile_message="Pass: /etc/dconf/profile/gdm exists and has the correct contents."
        profile_result="Pass"
    else
        profile_message="Fail: /etc/dconf/profile/gdm exists but does not have the correct contents."
        profile_result="Fail"
    fi
else
    profile_message="Fail: /etc/dconf/profile/gdm does not exist."
    profile_result="Fail"
fi

# Verify the existence and contents of a file in /etc/dconf/db/gdm.d/
gdm_file="/etc/dconf/db/gdm.d/00-login-screen"
if [ -f "$gdm_file" ]; then
    gdm_contents=$(<"$gdm_file")
    if [[ "$gdm_contents" == *"[org/gnome/login-screen]"* && "$gdm_contents" == *"disable-user-list=true"* ]]; then
        last_login_message="Pass: $gdm_file exists and has the correct structure."
        gdm_result="Pass"
    else
        last_login_message="Fail: $gdm_file exists but does not have the correct structure."
        gdm_result="Fail"
    fi
else
    last_login_message="Fail: $gdm_file does not exist."
    gdm_result="Fail"
fi

# Output the overall result
if [ "$profile_result" == "Pass" ] && [ "$gdm_result" == "Pass" ]; then
    last_login_result="Pass"
else
    last_login_result="Fail"
fi

# 1.8.4 Ensure XDMCP is not enabled
# Run the command and store the output
xdmcp_output=$(grep -Eis '^\s*Enable\s*=\s*true' /etc/gdm/custom.conf)

# Check if the output is empty
if [ -z "$xdmcp_output" ]; then
    xdmcp_message="Pass: No lines matching the pattern were found in /etc/gdm/custom.conf."
    xdmcp_result="Pass"
else
    xdmcp_message="Fail: Lines matching the pattern were found in /etc/gdm/custom.conf."
    xdmcp_result="Fail"
fi

# 2.1.1 Ensure time synchronization is in use
# Run the command to check if chrony is installed
chrony_rpm_output=$(rpm -q chrony)

# Check if chrony is installed
if [[ $chrony_rpm_output == *"chrony"* ]]; then
    chrony_installed_message="Pass: chrony is installed."
    chrony_installed_result="Pass"
else
    chrony_installed_message="Fail: chrony is not installed."
    chrony_installed_result="Fail"
fi

# Output the overall result
echo "Overall Result: $result"

# 2.1.2 Ensure chrony is configured
# Verify remote server configuration in chrony.conf
chrony_remote_server=$(grep -E "^(server|pool)" /etc/chrony.conf | awk '{print $2}')
if [ -n "$chrony_remote_server" ]; then
    chrony_remote_server_message="Pass: Remote server is configured properly: $chrony_remote_server"
else
    chrony_remote_server_message="Fail: Remote server is not configured properly."
fi

# Verify OPTIONS includes '-u chrony' in /etc/sysconfig/chronyd
chrony_config_options=$(grep ^OPTIONS /etc/sysconfig/chronyd | grep -q '\-u chrony' && echo "true" || echo "false")
if [ "$chrony_config_options" = "true" ]; then
   chrony_config_options_message="Pass: OPTIONS includes '-u chrony'."
else
    chrony_config_options_message="Fail: OPTIONS does not include '-u chrony'."
fi

# Overall result
if [ -n "$chrony_remote_server" ] && [ "$chrony_config_options" = "true" ]; then
    chrony_config_result="Pass"
else
    chrony_config_result="Fail"
fi

# 2.2.1 Ensure xinetd is not installed
# Check if xinetd is installed
if rpm -q xinetd &> /dev/null; then
    xinetd_message="Fail: xinetd is installed."
    xinetd_result="Fail"
else
    xinetd_message="Pass: xinetd is not installed."
    xinetd_result="Pass"
fi

# 2.2.5 Ensure DHCP Server is not installed
# Check if dhcp-server is installed
if rpm -q dhcp-server &> /dev/null; then
    dhcp_installed_message="Fail: dhcp-server is installed."
    dhcp_installed_result="Fail"
else
    dhcp_installed_message="Pass: dhcp-server is not installed."
    dhcp_installed_result="Fail"
fi

# 2.2.6 Ensure DNS Server is not installed
# Check if bind is installed
if rpm -q bind &> /dev/null; then
    dns_installed_message="Fail: bind is installed."
    dns_installed_result="Fail"
else
    dns_installed_message="Pass: bind is not installed."
    dns_installed_result="Pass"
fi

# 2.2.7 Ensure FTP Server is not installed
# Check if ftp is installed
if rpm -q ftp &> /dev/null; then
    ftp_installed_message="Fail: ftp is installed."
    ftp_installed_result="Fail"
else
    ftp_installed_message="Pass: ftp is not installed."
    ftp_installed_result="Pass"
fi

# 2.2.8 Ensure VSFTP Server is not installed
# Check if vsftpd is installed
if rpm -q vsftpd &> /dev/null; then
    vsftpd_installed_message="Fail: vsftpd is installed."
    vsftpd_installed_result="Fail"
else
    vsftpd_installed_message="Pass: vsftpd is not installed."
    vsftpd_installed_result="Pass"
fi

# 2.2.9 Ensure TFTP Server is not installed
# Check if tftp-server is installed
if rpm -q tftp-server &> /dev/null; then
    tftp_installed_message="Fail: tftp-server is installed."
    tftp_installed_result="Fail"
else
    tftp_installed_message="Pass: tftp-server is not installed."
    tftp_installed_result="Pass"
fi

# 2.2.10 Ensure a web server is not installed
# Check if httpd and nginx are not installed
if rpm -q httpd &> /dev/null && rpm -q nginx &> /dev/null; then
    web_server_installed_message="Fail: httpd and nginx are installed."
    web_server_installed_result="Fail"
else
    web_server_installed_message="Pass: httpd and nginx are not installed."
    web_server_installed_result="Pass"
fi

# 2.2.11 Ensure IMAP and POP3 server is not installed
# Check if dovecot and cyrus-imapd are not installed
if rpm -q dovecot &> /dev/null && rpm -q cyrus-imapd &> /dev/null; then
    imap_pop3_installed_message="Fail: dovecot and cyrus-imapd are installed."
    imap_pop3_installed_result="Fail"
else
    imap_pop3_installed_message="Pass: dovecot and cyrus-imapd are not installed."
    imap_pop3_installed_result="Pass"
fi

# 2.2.12 Ensure Samba is not installed
# Check if samba is not installed
if rpm -q samba &> /dev/null; then
    samba_installed_message="Fail: Samba is installed."
    samba_installed_result="Fail"
else
    samba_installed_message="Pass: Samba is not installed."
    samba_installed_result="Pass"
fi

# 2.2.13 Ensure HTTP Proxy Server is not installed
# Check if squid is not installed
if rpm -q squid &> /dev/null; then
    squid_installed_message="Fail: Squid is installed."
    squid_installed_result="Fail"
else
    squid_installed_message="Pass: Squid is not installed."
    squid_installed_result="Pass"
fi

# 2.2.14 Ensure net-snmp is not installed
# Check if net-snmp is not installed
if rpm -q net-snmp &> /dev/null; then
    net_snmp_installed_message="Fail: net-snmp is installed."
    net_snmp_installed_result="Fail"
else
    net_snmp_installed_message="Pass: net-snmp is not installed."
    net_snmp_installed_result="Pass"
fi

# 2.2.15 Ensure NIS server is not installed
# Check if ypserv is not installed
if rpm -q ypserv &> /dev/null; then
    nis_installed_message="Fail: ypserv is installed."
    nis_installed_result="Fail"
else
    nis_installed_message="Pass: ypserv is not installed."
    nis_installed_result="Pass"
fi

# 2.2.16 Ensure telnet-server is not installed
# Check if telnet-server is not installed
if rpm -q telnet-server &> /dev/null; then
    telnet_installed_message="Fail: telnet-server is installed."
    telnet_installed_result="Fail"
else
    telnet_installed_message="Pass: telnet-server is not installed."
    telnet_installed_result="Pass"
fi

# 2.2.17 Ensure mail transfer agent is configured for local-only mode
# Check if MTA is not listening on any non-loopback address
if ss -lntu | grep -E ':25\s' | grep -E -v '\s(127.0.0.1|\[?::1\]?):25\s' &> /dev/null; then
    mta_not_listen_loopbackAddr_message="Fail: MTA is listening on non-loopback addresses."
    mta_not_listen_loopbackAddr_result="Fail"
else
    mta_not_listen_loopbackAddr_message="Pass: MTA is not listening on non-loopback addresses."
    mta_not_listen_loopbackAddr_result="Pass"
fi

# 2.2.18 Ensure nfs-utils is not installed or the  nfs-server service is masked
# Flag to track overall result
overall_result=0

# Check if nfs-utils package is not installed
if ! rpm -q nfs-utils &> /dev/null; then
    nfs_utils_installed_message="Pass: nfs-utils package is not installed."
else
    nfs_utils_installed_message="Fail: nfs-utils package is installed."
    overall_result=1
fi

# Check if nfs-server service is masked
if systemctl is-enabled nfs-server | grep -q masked; then
    nfs_server_enabled_message="Pass: nfs-server service is masked."
else
    nfs_server_enabled_message="Fail: nfs-server service is not masked."
    overall_result=1
fi

# Output overall result
if [ $overall_result -eq 0 ]; then
    nfs_utils_installed_result="Pass"
else
    nfs_utils_installed_result="Overall Result: Fail"
fi

# 2.2.19 Ensure rpcbind is not installed or the  rpcbind services are masked
# Flag to track overall result
overall_result=0

# Check if rpcbind package is not installed
if ! rpm -q rpcbind &> /dev/null; then
    rpcbind_installed_message="Pass: rpcbind package is not installed."
else
    rpcbind_installed_message="Fail: rpcbind package is installed."
    overall_result=1
fi

# Check if rpcbind and rpcbind.socket services are masked
if systemctl is-enabled rpcbind | grep -q masked; then
    rpcbind_masked_message="Pass: rpcbind services are masked."
else
    rpcbind_masked_message="Fail: rpcbind are not masked."
    overall_result=1
fi

if systemctl is-enabled rpcbind.socket | grep -q masked; then
    rpcbind_socket_masked_message="Pass: rpcbind.socket services are masked."
else
    rpcbind_socket_masked_message="Fail: rpcbind.socket services are not masked."
    overall_result=1
fi

# Output overall result
if [ $overall_result -eq 0 ]; then
    rpcbind_installed_masked_result="Pass"
else
    rpcbind_installed_masked_result="Fail"
fi

# 2.2.20 Ensure rsync is not installed or the rsyncd service is masked
# Flag to track overall result
overall_result=0

# Check if rsync package is not installed
if ! rpm -q rsync &> /dev/null; then
    rsync_installed_message="Pass: rsync package is not installed."
else
    rsync_installed_message="Fail: rsync package is installed."
    overall_result=1
fi

# Check if rsyncd service is masked
if systemctl is-enabled rsyncd | grep -q masked; then
    rsyncd_masked_message="Pass: rsyncd service is masked."
else
    rsyncd_masked_message="Fail: rsyncd service is not masked."
    overall_result=1
fi

# Output overall result
if [ $overall_result -eq 0 ]; then
    rsync_installed_masked_result="Pass"
else
    rsync_installed_masked_result="Fail"
fi

# 2.3.1 Ensure NIS Client is not installed
# Check if ypbind package is not installed
if ! rpm -q ypbind &> /dev/null; then
    nis_client_installed_message="Pass: ypbind package is not installed."
    nis_client_installed_result="Pass"
else
    nis_client_installed_message="Fail: ypbind package is installed."
    nis_client_installed_result="Fail"
fi

# 2.3.2 Ensure rsh client is not installed
# Check if rsh package is not installed
if ! rpm -q rsh &> /dev/null; then
    rsh_client_installed_message="Pass: rsh package is not installed."
    rsh_client_installed_result="Pass"
else
    rsh_client_installed_message="Fail: rsh package is installed."
    rsh_client_installed_result="Fail"
fi

# 2.3.3 Ensure talk client is not installed
# Check if talk package is not installed
if ! rpm -q talk &> /dev/null; then
    talk_client_installed_message="Pass: talk package is not installed."
    talk_client_result="Pass"
else
    talk_client_installed_message="Fail: talk package is installed."
    talk_client_result="Fail"
fi

# 2.3.4 Ensure telnet client is not installed
# Check if telnet package is not installed
if ! rpm -q telnet &> /dev/null; then
    telnet_client_message="Pass: telnet package is not installed."
    telnet_client_result="Pass"
else
    telnet_client_message="Fail: telnet package is installed."
    telnet_client_result="Fail"
fi

# 2.3.5 Ensure LDAP client is not installed
# Check if openldap-clients package is not installed
if ! rpm -q openldap-clients &> /dev/null; then
    ldap_client_installed_message="Pass: openldap-clients package is not installed."
    ldap_client_installed_result="Pass"
else
    ldap_client_installed_message="Fail: openldap-clients package is installed."
    ldap_client_installed_result="Fail"
fi

# 2.3.6 Ensure TFTP client is not installed
# Check if tftp package is not installed
if ! rpm -q tftp &> /dev/null; then
    tftp_client_installed_message="Pass: tftp package is not installed."
    tftp_client_installed_result="Pass"
else
    tftp_client_installed_message="Fail: tftp package is installed."
    tftp_client_installed_result="Fail"
fi

# 3.2.1 Ensure IP forwarding is disabled
# Function to check IPv4 ip_forwarding
check_ipv4_ip_forwarding() {
    krp=""
    pafile=""
    fafile=""
    kpname="net.ipv4.ip_forward"
    kpvalue="0"
    searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"
    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
	ipv4_forwarding_result="Pass"        
	ipv4_forwarding_message="$'\n'IPv4 PASS:$'\n'\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
	ipv4_forwarding_result="Fail"
        ipv4_forwarding_message="$'\n'IPv4 FAIL: "
	if [ "$krp" != "$kpvalue" ]; then
		ipv4_forwarding_message+="\"$kpname\" is set to \"$krp\" in the running configuration$'\n'"
	fi

	if [ -n "$fafile" ]; then
		ipv4_forwarding_message+="$'\n'\"$kpname\" is set incorrectly in \"$fafile\""
	fi

	if [ -z "$pafile" ]; then
		ipv4_forwarding_message+="$'\n'\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file$'\n'"
	fi
    fi
}

# Function to check IPv6 forwarding
check_ipv6_forwarding() {
    krp=""
    pafile=""
    fafile=""
    kpname="net.ipv6.conf.all.forwarding"
    kpvalue="0"
    searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"
    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
	ipv6_forwarding_result="Pass"        
	ipv6_forwarding_message="$'\n'IPv6 PASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
	ipv6_forwarding_result="Fail"
        ipv6_forwarding_message="$'\n'IPv6 FAIL: "

	if [ "$krp" != "$kpvalue" ]; then
		ipv6_forwarding_message+="\"$kpname\" is set to \"$krp\" in the running configuration$'\n'"
	fi

	if [ -n "$fafile" ]; then
		ipv6_forwarding_message+="$'\n'\"$kpname\" is set incorrectly in \"$fafile\""
	fi

	if [ -z "$pafile" ]; then
		ipv6_forwarding_message+="$'\n'\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file$'\n'"
	fi
    fi
}

# Check if IPv6 is enabled
ipv6_enabled="$(sysctl -n net.ipv6.conf.all.disable_ipv6)"
if [ "$ipv6_enabled" -eq "0" ]; then
    # IPv6 is enabled, so check IPv6 forwarding
    check_ipv6_forwarding
fi

# Check IPv4 forwarding
check_ipv4_ip_forwarding

# Get overall result
    if [ "$ipv4_forwarding_result" = "Fail" ]; then
        ip_forwarding_overall_result="Fail"
    elif [ "$ipv6_forwarding_result" = "Fail" ]; then
        ip_forwarding_overall_result="Fail"
    elif [ "$ipv6_enabled" -eq "0" ]; then
        ip_forwarding_overall_result="Fail"
    else
        ip_forwarding_overall_result="Pass"
    fi

# 3.2.2 Ensure packet redirect sending is disabled
# Function to check send_redirects parameter for IPv4 configuration

check_ipv4_all_redirect() {
 krp="" 
 pafile="" 
 fafile=""
 kpname="net.ipv4.conf.all.send_redirects" 
 kpvalue="0"
 searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
 krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
 pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
 fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"
 if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
	ipv4_redirect_all_result="Pass" 	
	ipv4_redirect_all_message="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
 else
	ipv4_redirect_all_result="Fail" 	
	ipv4_redirect_all_message="\nFAIL: "
 	[ "$krp" != "$kpvalue" ] && ipv4_redirect_all_message=+"\"$kpname\" is set to \"$krp\" in the running configuration\n"
 	[ -n "$fafile" ] && ipv4_redirect_all_message=+"\n\"$kpname\" is set incorrectly in \"$fafile\""
 	[ -z "$pafile" ] && ipv4_redirect_all_message=+"\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
 fi
}

check_ipv4_default_redirect() {
 krp="" 
 pafile="" 
 fafile=""
 kpname="net.ipv4.conf.default.send_redirects" 
 kpvalue="0"
 searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
 krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
 pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
 fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"
 if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
	ipv4_redirect_default_result="Pass"
	ipv4_redirect_default_message="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
 else
 	ipv4_redirect_default_result="Fail"
	ipv4_redirect_default_message="\nFAIL: "
 	[ "$krp" != "$kpvalue" ] && ipv4_redirect_default_message=+"\"$kpname\" is set to \"$krp\" in the running configuration\n"
 	[ -n "$fafile" ] && ipv4_redirect_default_message=+"\n\"$kpname\" is set incorrectly in \"$fafile\""
 	[ -z "$pafile" ] && ipv4_redirect_default_message=+"\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
 fi
}

# Check net.ipv4.conf.all.send_redirects
check_ipv4_all_redirect

# Check net.ipv4.conf.default.send_redirects
check_ipv4_default_redirect

if [[ "$ipv4_redirect_default_result" = "Pass" && "$ipv4_redirect_all_result" = "Pass" ]]; then
        ip_redirect_overall_result="Pass"
else
	ip_redirect_overall_result="Fail"
fi

# 3.3.1 Ensure source routed packets are not accepted
# Function to verify IPv4 kernel parameter
source_routed_packets_verify_ipv4_kernel_parameter() {
    local kpname="$1"
    local kpvalue="$2"
    local krp=""
    local pafile=""
    local fafile=""
    local pass_msg=""
    local fail_msg=""
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
        pass_msg+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        fail_msg+="\nFAIL: "
        [ "$krp" != "$kpvalue" ] && fail_msg+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
        [ -n "$fafile" ] && fail_msg+="\n\"$kpname\" is set incorrectly in \"$fafile\""
        [ -z "$pafile" ] && fail_msg+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    fi

    source_routed_packets_pass_result="${source_routed_packets_pass_result}${pass_msg}"
    source_routed_packets_fail_result="${source_routed_packets_fail_result}${fail_msg}"

    # Increment the count of failed items
    if [ -n "$fail_msg" ]; then
        ((count++))
    fi
}

# Function to verify IPv6 kernel parameter
source_routed_packets_verify_ipv6_kernel_parameter() {
    local kpname="$1"
    local kpvalue="$2"
    local krp=""
    local pafile=""
    local fafile=""
    local pass_msg=""
    local fail_msg=""
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
        pass_msg+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        fail_msg+="\nFAIL: "
        [ "$krp" != "$kpvalue" ] && fail_msg+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
        [ -n "$fafile" ] && fail_msg+="\n\"$kpname\" is set incorrectly in \"$fafile\""
        [ -z "$pafile" ] && fail_msg+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    fi

    source_routed_packets_pass_result="${source_routed_packets_pass_result}${pass_msg}"
    source_routed_packets_fail_result="${source_routed_packets_fail_result}${fail_msg}"

    # Increment the count of failed items
    if [ -n "$fail_msg" ]; then
        ((count++))
    fi
}

# Initialize variables to hold results
source_routed_packets_pass_result=""
source_routed_packets_fail_result=""
count=0

# Verify IPv4 kernel parameters
source_routed_packets_verify_ipv4_kernel_parameter "net.ipv4.conf.all.accept_source_route" "0"
source_routed_packets_verify_ipv4_kernel_parameter "net.ipv4.conf.default.accept_source_route" "0"

# Check if IPv6 is enabled
ipv6_enabled=$(sysctl -n net.ipv6.conf.all.disable_ipv6)
if [ "$ipv6_enabled" -eq 0 ]; then
    # Verify IPv6 kernel parameter
    source_routed_packets_verify_ipv6_kernel_parameter "net.ipv6.conf.all.accept_source_route" "0"
fi

# Determine overall result based on the count of failed items
if [ "$count" -gt 0 ]; then
    source_routed_packets_pass_overall_result="FAIL"
else
    source_routed_packets_pass_overall_result="PASS"
fi

# 3.3.2 Ensure ICMP redirects are not accepted
# Function to verify IPv4 kernel parameter
icmp_redirect_verify_ipv4_kernel_parameter() {
    local kpname="$1"
    local kpvalue="$2"
    local krp=""
    local pafile=""
    local fafile=""
    local icmp_redirect_msg=""
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
        icmp_redirect_msg+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        icmp_redirect_msg+="\nFAIL: \n"
        [ "$krp" != "$kpvalue" ] && icmp_redirect_msg+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
        [ -n "$fafile" ] && icmp_redirect_msg+="\n\"$kpname\" is set incorrectly in \"$fafile\""
        [ -z "$pafile" ] && icmp_redirect_msg+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
        ((count++))
    fi

    icmp_redirect_result="${icmp_redirect_result}${icmp_redirect_msg}"

}

# Function to verify IPv6 kernel parameter
icmp_redirect_verify_ipv6_kernel_parameter() {
    local kpname="$1"
    local kpvalue="$2"
    local krp=""
    local pafile=""
    local fafile=""
    local icmp_redirect_msg=""
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
        icmp_redirect_msg+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        icmp_redirect_msg+="\nFAIL: \n"
        [ "$krp" != "$kpvalue" ] && icmp_redirect_msg+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
        [ -n "$fafile" ] && icmp_redirect_msg+="\n\"$kpname\" is set incorrectly in \"$fafile\""
        [ -z "$pafile" ] && icmp_redirect_msg+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
        ((count++))
    fi

    icmp_redirect_result="${icmp_redirect_result}${icmp_redirect_msg}"

}

# Initialize variables to hold results
icmp_redirect_result=""
count=0

# Verify IPv4 kernel parameters
icmp_redirect_verify_ipv4_kernel_parameter "net.ipv4.conf.all.accept_redirects" "0"
icmp_redirect_verify_ipv4_kernel_parameter "net.ipv4.conf.default.accept_redirects" "0"

# Check if IPv6 is enabled
ipv6_enabled=$(sysctl -n net.ipv6.conf.all.disable_ipv6)
if [ "$ipv6_enabled" -eq 0 ]; then
    # Verify IPv6 kernel parameters
    icmp_redirect_verify_ipv6_kernel_parameter "net.ipv6.conf.all.accept_redirects" "0"
    icmp_redirect_verify_ipv6_kernel_parameter "net.ipv6.conf.default.accept_redirects" "0"
fi

# Determine overall result based on the count of failed items
if [ "$count" -gt 0 ]; then
    icmp_redirect_overall_result="FAIL"
else
    icmp_redirect_overall_result="PASS"
fi

# 3.3.3 Ensure secure ICMP redirects are not accepted
# Function to verify IPv4 kernel parameter
secure_icmp_redirect_verify_ipv4_kernel_parameter() {
    local kpname="$1"
    local kpvalue="$2"
    local krp=""
    local pafile=""
    local fafile=""
    local secure_icmp_msg=""
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

    krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
    pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
    fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
        secure_icmp_msg+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    else
        secure_icmp_msg+="\nFAIL: "
        [ "$krp" != "$kpvalue" ] && secure_icmp_msg+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
        [ -n "$fafile" ] && secure_icmp_msg+="\n\"$kpname\" is set incorrectly in \"$fafile\""
        [ -z "$pafile" ] && secure_icmp_msg+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    fi

    secure_icmp_result="${secure_icmp_result}${secure_icmp_msg}"

    # Increment the count of failed items
    if [ -n "$fail_msg" ]; then
        ((count++))
    fi
}

# Initialize variables to hold results
secure_icmp_result=""
count=0

# Verify IPv4 kernel parameters
secure_icmp_redirect_verify_ipv4_kernel_parameter "net.ipv4.conf.all.secure_redirects" "0"
secure_icmp_redirect_verify_ipv4_kernel_parameter "net.ipv4.conf.default.secure_redirects" "0"

# Determine overall result based on the count of failed items
if [ "$count" -gt 0 ]; then
    secure_icmp_overall_result="FAIL"
else
    secure_icmp_overall_result="PASS"
fi


# 3.3.4	Ensure suspicious packets are logged
suspicious_packets_logged_overall_result="Pass"
suspicious_packets_logged_result_message=""

suspicious_packets_logged_check_param() {
  local kpname="$1"
  local kpvalue="$2"
  local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
  
  local krp
  local pafile
  local fafile

  krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
  pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
  fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

  if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
    suspicious_packets_logged_result_message+="\nPASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
  else
    suspicious_packets_logged_result_message+="\nFAIL: "
    suspicious_packets_logged_overall_result="Fail"
    [ "$krp" != "$kpvalue" ] && suspicious_packets_logged_result_message+="\n\"$kpname\" is set to \"$krp\" in the running configuration\n"
    [ -n "$fafile" ] && suspicious_packets_logged_result_message+="\n\"$kpname\" is set incorrectly in \"$fafile\""
    [ -z "$pafile" ] && suspicious_packets_logged_result_message+="\n\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
  fi
}

suspicious_packets_logged_check_param "net.ipv4.conf.all.log_martians" "1"
suspicious_packets_logged_check_param "net.ipv4.conf.default.log_martians" "1"

# 3.3.5	Ensure broadcast ICMP requests are ignored
  broadcast_ICMP_request_message=""
  broadcast_ICMP_request_result=""
Broadcast_ICMP_Request(){
  krp="" pafile="" fafile=""
  kpname="net.ipv4.icmp_echo_ignore_broadcasts"
  kpvalue="1"
  searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
  krp="$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)"
  pafile="$(grep -Psl -- "^\h*$kpname\h*=\h*$kpvalue\b\h*(#.*)?$" $searchloc)"
  fafile="$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\h*=\h*$kpvalue\b\h*" | awk -F: '{print $1}')"

  if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
    broadcast_ICMP_request_message="PASS:\n\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\""
    broadcast_ICMP_request_result="PASS"
  else
    broadcast_ICMP_request_message="FAIL: "
    [ "$krp" != "$kpvalue" ] && broadcast_ICMP_request_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
    [ -n "$fafile" ] && broadcast_ICMP_request_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
    [ -z "$pafile" ] && broadcast_ICMP_request_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    broadcast_ICMP_request_result="FAIL"
  fi
}
Broadcast_ICMP_Request

# 3.3.6	Ensure bogus ICMP responses are ignored
icmp_ignore_bogus_error_message=""
icmp_ignore_bogus_error_result=""
audit_icmp_ignore_bogus_error_responses() {
  local kpname="net.ipv4.icmp_ignore_bogus_error_responses"
  local kpvalue="1"
  local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
  local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
  local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
  local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

  if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
    icmp_ignore_bogus_error_message+="PASS:\n"
    icmp_ignore_bogus_error_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
    icmp_ignore_bogus_error_result="PASS"
  else
    icmp_ignore_bogus_error_message+="FAIL:\n"
    [ "$krp" != "$kpvalue" ] && icmp_ignore_bogus_error_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
    [ -n "$fafile" ] && icmp_ignore_bogus_error_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
    [ -z "$pafile" ] && icmp_ignore_bogus_error_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    icmp_ignore_bogus_error_result="FAIL"
  fi
}

# Run the audit function
audit_icmp_ignore_bogus_error_responses

# 3.3.7	Ensure Reverse Path Filtering is enabled
reverse_path_filtering_message=""
reverse_path_filtering_result=""

audit_net_ipv4_rp_filters() {
  local audit_message=""
  local overall_result="Pass"

  # Function to audit net.ipv4.conf.all.rp_filter
  audit_net_ipv4_conf_all_rp_filter() {
    local kpname="net.ipv4.conf.all.rp_filter"
    local kpvalue="1"
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
    local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
    local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
      audit_message+="PASS:\n"
      audit_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
    else
      audit_message+="FAIL:\n"
      [ "$krp" != "$kpvalue" ] && audit_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
      [ -n "$fafile" ] && audit_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
      [ -z "$pafile" ] && audit_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
      overall_result="FAIL"
    fi
  }

  # Function to audit net.ipv4.conf.default.rp_filter
  audit_net_ipv4_conf_default_rp_filter() {
    local kpname="net.ipv4.conf.default.rp_filter"
    local kpvalue="1"
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
    local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
    local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
      audit_message+="\nPASS:\n"
      audit_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
    else
      audit_message+="\nFAIL:\n"
      [ "$krp" != "$kpvalue" ] && audit_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
      [ -n "$fafile" ] && audit_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
      [ -z "$pafile" ] && audit_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
      overall_result="FAIL"
    fi
  }

  # Run the audit functions
  audit_net_ipv4_conf_all_rp_filter
  audit_net_ipv4_conf_default_rp_filter

  reverse_path_filtering_message=$audit_message
  reverse_path_filtering_result=$overall_result
}

# Run the combined audit function
audit_net_ipv4_rp_filters

# 3.3.8	Ensure TCP SYN Cookies is enabled
tcp_syn_cookies_message=""
tcp_syn_cookies_result=""

audit_net_ipv4_tcp_syncookies(){ 
  local kpname="net.ipv4.tcp_syncookies"
  local kpvalue="1"
  local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
  local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
  local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
  local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

  if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
    tcp_syn_cookies_message+="PASS:\n"
    tcp_syn_cookies_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
    tcp_syn_cookies_result="PASS"
  else
    tcp_syn_cookies_message+="FAIL:\n"
    [ "$krp" != "$kpvalue" ] && tcp_syn_cookies_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
    [ -n "$fafile" ] && tcp_syn_cookies_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
    [ -z "$pafile" ] && tcp_syn_cookies_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
    tcp_syn_cookies_result="FAIL"
  fi

}

# Run the audit function
audit_net_ipv4_tcp_syncookies

# 3.3.9	Ensure IPv6 router advertisements are not accepted
ipv6_router_advertisements_message=""
ipv6_router_advertisements_result=""

audit_net_ipv6_accept_ra() {
  local audit_message=""
  local overall_result=""

  # Function to audit net.ipv6.conf.all.accept_ra
  audit_net_ipv6_conf_all_accept_ra() {
    local kpname="net.ipv6.conf.all.accept_ra"
    local kpvalue="0"
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
    local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
    local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
      audit_message+="PASS:\n"
      audit_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
      overall_result="PASS"
    else
      audit_message+="FAIL:\n"
      [ "$krp" != "$kpvalue" ] && audit_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
      [ -n "$fafile" ] && audit_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
      [ -z "$pafile" ] && audit_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
      overall_result="FAIL"
    fi
  }

  # Function to audit net.ipv6.conf.default.accept_ra
  audit_net_ipv6_conf_default_accept_ra() {
    local kpname="net.ipv6.conf.default.accept_ra"
    local kpvalue="0"
    local searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
    local krp=$(sysctl "$kpname" | awk -F= '{print $2}' | xargs)
    local pafile=$(grep -Psl -- "^\s*$kpname\s*=\s*$kpvalue\b\s*(#.*)?$" $searchloc)
    local fafile=$(grep -s -- "^\s*$kpname" $searchloc | grep -Pv -- "\s*=\s*$kpvalue\b\s*" | awk -F: '{print $1}')

    if [ "$krp" = "$kpvalue" ] && [ -n "$pafile" ] && [ -z "$fafile" ]; then
      audit_message+="\nPASS:\n"
      audit_message+="\"$kpname\" is set to \"$kpvalue\" in the running configuration and in \"$pafile\"\n"
      overall_result="PASS"
    else
      audit_message+="\nFAIL:\n"
      [ "$krp" != "$kpvalue" ] && audit_message+="\"$kpname\" is set to \"$krp\" in the running configuration\n"
      [ -n "$fafile" ] && audit_message+="\"$kpname\" is set incorrectly in \"$fafile\"\n"
      [ -z "$pafile" ] && audit_message+="\"$kpname = $kpvalue\" is not set in a kernel parameter configuration file\n"
      overall_result="FAIL"
    fi
  }

  # Function to check IPv6 status
  check_ipv6_status() {
    local ipv6_enabled=$(sysctl net.ipv6.conf.all.disable_ipv6 | awk -F= '{print $2}' | xargs)

    if [ "$ipv6_enabled" = "0" ]; then
      audit_message+="\nIPv6 is enabled on the system.\n"
      overall_result="FAIL"
    else
      audit_message+="\nIPv6 is disabled on the system.\n"
      overall_result="PASS"
    fi
  }

  # Run the audit functions
  audit_net_ipv6_conf_all_accept_ra
  audit_net_ipv6_conf_default_accept_ra

  # Check conditions based on audit results
  if [ "$overall_result" = "FAIL" ]; then
    check_ipv6_status
  fi

  ipv6_router_advertisements_message=$audit_message
  ipv6_router_advertisements_result=$overall_result
}

# Run the combined audit function
audit_net_ipv6_accept_ra

# 3.4.1.1	Ensure firewalld is installed
firewalld_message=""
firewalld_result="Pass"

audit_firewall_iptables() {

  # Check if Firewalld is installed
  if rpm -q firewalld &>/dev/null; then
    firewalld_message+="Pass: Firewalld is installed: $(rpm -q firewalld)\n"
  else
    firewalld_message+="Fail: Firewalld is not installed.\n"
    firewalld_result="FAIL"
  fi

  # Check if iptables is installed
  if rpm -q iptables &>/dev/null; then
    firewalld_message+="Pass: iptables is installed: $(rpm -q iptables)\n"
  else
    firewalld_message+="Fail: iptables is not installed.\n"
    firewalld_result="FAIL"
  fi
}

# Run the audit function
audit_firewall_iptables

# 3.4.1.2	Ensure iptables-services not installed with firewalld
  iptables_services_installed_message=""
  iptables_services_installed_result="PASS"

  # Check if iptables-services is installed
  if rpm -q iptables-services &>/dev/null; then
    iptables_services_installed_message+="Fail: iptables-services is installed: $(rpm -q iptables-services)\n"
    iptables_services_installed_result="FAIL"
  else
    iptables_services_installed_message+="Pass: iptables-services is not installed.\n"
  fi

# 3.4.1.3	Ensure nftables either not installed or masked with firewalld
nftables_installed_masked_message=""
nftables_installed_masked_result=""

audit_nftables() {
  local audit_message=""
  local overall_result="FAIL"

  # Check if nftables package is not installed
  if ! rpm -q nftables &>/dev/null; then
    audit_message+="Pass: nftables package is not installed.\n"
    overall_result="PASS"
  else
    audit_message+="Fail: nftables package is installed: $(rpm -q nftables)\n"
  fi

  # Check if nftables service is inactive
  local nftables_active=$(systemctl is-active nftables)
  if [ "$nftables_active" = "inactive" ]; then
    audit_message+="Pass: nftables service is inactive.\n"
    overall_result="PASS"
  else
    audit_message+="Fail: nftables service is active: $nftables_active\n"
  fi

  # Check if nftables service is masked
  local nftables_enabled=$(systemctl is-enabled nftables)
  if [ "$nftables_enabled" = "masked" ]; then
    audit_message+="Pass: nftables service is masked.\n"
    overall_result="PASS"
  else
    audit_message+="Fail: nftables service is not masked: $nftables_enabled\n"
  fi

  nftables_installed_masked_message=$audit_message
  nftables_installed_masked_result=$overall_result
}

# Run the audit function
audit_nftables

# 3.4.1.4	Ensure firewalld service enabled and running
firewalld_service_enabled_running_message=""
firewalld_service_enabled_running_result=""
audit_firewalld_enabled_running() {
  local audit_message=""
  local overall_result="PASS"

  # Check if firewalld is enabled
  local firewalld_enabled=$(systemctl is-enabled firewalld)
  if [ "$firewalld_enabled" = "enabled" ]; then
    audit_message+="Pass: firewalld is enabled.\n"
  else
    audit_message+="Fail: firewalld is not enabled: $firewalld_enabled\n"
    overall_result="FAIL"
  fi

  # Check if firewalld is running
  local firewalld_state=$(firewall-cmd --state)
  if [ "$firewalld_state" = "running" ]; then
    audit_message+="Pass: firewalld is running.\n"
  else
    audit_message+="Fail: firewalld is not running: $firewalld_state\n"
    overall_result="FAIL"
  fi

  # Print the audit message and overall result
  echo -e "\nAudit Result for firewalld Status:"
  firewalld_service_enabled_running_message=$audit_message
  firewalld_service_enabled_running_result=$overall_result
}

# Run the audit function
audit_firewalld_enabled_running

# 3.4.2.1	Ensure nftables is installed
nftables_installed_message=""
nftables_installed_result=""

audit_nftables_installation() {
  local audit_message=""
  local overall_result="PASS"

  # Check if nftables package is installed
  if rpm -q nftables &>/dev/null; then
    nftables_version=$(rpm -q nftables)
    audit_message+="nftables package is installed: $nftables_version\n"
  else
    audit_message+="nftables package is not installed.\n"
    overall_result="FAIL"
  fi

  nftables_installed_message=$audit_message
  nftables_installed_result=$overall_result
}

# Run the audit function
audit_nftables_installation

# 3.4.2.2	Ensure firewalld is either not installed or masked with nftables
firewalld_installed_masked_message=""
firewalld_installed_masked_result=""

audit_firewalld_installed_masked() {
  local audit_message=""
  local overall_result="PASS"

  # Check if firewalld package is not installed
  if ! rpm -q firewalld &>/dev/null; then
    audit_message+="firewalld package is not installed.\n"
  else
    audit_message+="firewalld package is installed.\n"
    overall_result="FAIL"
  fi

  # Check if firewall-cmd command exists and firewalld is not running
  if command -v firewall-cmd >/dev/null && ! firewall-cmd --state | grep -q 'running'; then
    audit_message+="firewalld is not running.\n"
  else
    audit_message+="firewalld is running or firewall-cmd command not found.\n"
    overall_result="FAIL"
  fi

  # Check if firewalld service is masked
  firewalld_enabled=$(systemctl is-enabled firewalld)
  if [ "$firewalld_enabled" = "masked" ]; then
    audit_message+="firewalld service is masked.\n"
  else
    audit_message+="firewalld service is not masked: $firewalld_enabled\n"
    overall_result="FAIL"
  fi

  # Print the audit message and overall result
  firewalld_installed_masked_message=$audit_message
  firewalld_installed_masked_result=$overall_result
}

# Run the audit function
audit_firewalld_installed_masked

# 3.4.2.3	Ensure iptables-services not installed with nftables
iptables_services_installed_message=""
iptables_services_installed_result=""

audit_iptables_services_installed() {
  local audit_message=""
  local overall_result="PASS"

  # Check if iptables-services package is not installed
  if ! rpm -q iptables-services &>/dev/null; then
    audit_message+="iptables-services package is not installed.\n"
  else
    audit_message+="iptables-services package is installed.\n"
    overall_result="FAIL"
  fi

  # Print the audit message and overall result
  iptables_services_installed_message=$audit_message
  iptables_services_installed_result=$overall_result
}

# Run the audit function
audit_iptables_services_installed

# 3.4.2.5	Ensure an nftables table exists
nftables_tables_exists_message=""
nftables_tables_exists_result=""

audit_nftables_tables_exists() {
  local audit_message=""
  local overall_result="FAIL"

  # Check if nftables tables exist
  tables=$(nft list tables 2>/dev/null)

  if [ -n "$tables" ]; then
    audit_message+="nftables tables found:\n$tables\n"
    overall_result="PASS"
  else
    audit_message+="No nftables tables found.\n"
  fi

  # Print the audit message and overall result
  nftables_tables_exists_message=$audit_message
  nftables_tables_exists_result=$overall_result
}

# Run the audit function
audit_nftables_tables_exists

#   3.4.2.6	Ensure nftables base chains exist
nftables_base_chains_result=""
nftables_base_chains_message=""

audit_nftables_base_chains() {
  local audit_message=""
  local overall_result="PASS"

  # Check base chain 'INPUT'
  if nft list ruleset | grep -q 'hook input'; then
    audit_message+="Pass: Base chain 'INPUT' found.\n"
  else
    audit_message+="Fail: Base chain 'INPUT' not found.\n"
    overall_result="FAIL"
  fi

  # Check base chain 'FORWARD'
  if nft list ruleset | grep -q 'hook forward'; then
    audit_message+="Pass: Base chain 'FORWARD' found.\n"
  else
    audit_message+="Fail: Base chain 'FORWARD' not found.\n"
    overall_result="FAIL"
  fi

  # Check base chain 'OUTPUT'
  if nft list ruleset | grep -q 'hook output'; then
    audit_message+="Pass: Base chain 'OUTPUT' found.\n"
  else
    audit_message+="Fail: Base chain 'OUTPUT' not found.\n"
    overall_result="FAIL"
  fi

  # Print the audit message and overall result
  nftables_base_chains_message=$audit_message
  nftables_base_chains_result=$overall_result
}

# Run the audit function
audit_nftables_base_chains

# 3.4.2.7	Ensure nftables loopback traffic is configured
# Function to check IPv6 status
ipv6_chk() {
  local passing=""
  local grubfile="$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)"
  ! grep -P -- "^\h*(kernelopts=|linux|kernel)" "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- "^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$" /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$" /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$" && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$" && passing="true"

  if [ "$passing" = true ]; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Variables to store messages and results
nftables_loopback_traffic_message=""
nftables_loopback_traffic_result="PASS"

# Check nftables rules for loopback interface
if nft list ruleset | awk '/hook input/,/}/' | grep -q 'iif "lo" accept'; then
  nftables_loopback_traffic_message+="PASS: Loopback interface is correctly configured to accept input\n"
else
  nftables_loopback_traffic_message+="FAIL: Loopback interface is not correctly configured to accept input\n"
  nftables_loopback_traffic_result="FAIL"
fi

if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip saddr 127.0.0.0/8 counter packets 0 bytes 0 drop'; then
  nftables_loopback_traffic_message+="PASS: IPv4 loopback source address is correctly configured to drop packets\n"
else
  nftables_loopback_traffic_message+="FAIL: IPv4 loopback source address is not correctly configured to drop packets\n"
  nftables_loopback_traffic_result="FAIL"
fi

# Check IPv6 status
if ipv6_chk; then
  nftables_loopback_traffic_message+="PASS: IPv6 is disabled on the system\n"
else
  if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip6 saddr ::1 counter packets 0 bytes 0 drop'; then
    nftables_loopback_traffic_message+="PASS: IPv6 loopback source address is correctly configured to drop packets\n"
  else
    nftables_loopback_traffic_message+="FAIL: IPv6 loopback source address is not correctly configured to drop packets\n"
    nftables_loopback_traffic_result="FAIL"
  fi
fi

# 3.4.2.9	Ensure nftables default deny firewall policy
# Variables to store messages and results
nftables_default_deny_firewall_message=""
nftables_default_deny_firewall_result="PASS"

# Function to check nftables policy
check_policy() {
  local hook=$1
  local expected_policy=$2
  local result

  if nft list ruleset | grep "hook $hook" | grep -q "policy $expected_policy"; then
    nftables_default_deny_firewall_message+="PASS: $hook chain has policy set to $expected_policy\n"
  else
    nftables_default_deny_firewall_message+="FAIL: $hook chain does not have policy set to $expected_policy\n"
    nftables_default_deny_firewall_result="FAIL"
  fi
}

# Check input chain policy
check_policy "input" "drop"

# Check forward chain policy
check_policy "forward" "drop"

# Check output chain policy
check_policy "output" "drop"

# 3.4.2.10	Ensure nftables service is enabled
# Variables to store messages and results
nftables_service_message=""
nftables_service_result="PASS"

# Function to check if the nftables service is enabled
check_nftables_service() {
  local result

  if systemctl is-enabled nftables | grep -q "enabled"; then
    nftables_service_message+="PASS: nftables service is enabled\n"
  else
    nftables_service_message+="FAIL: nftables service is not enabled\n"
    nftables_service_result="FAIL"
  fi
}

# Run the check
check_nftables_service

# 3.4.3.1.1	Ensure iptables packages are installed
# Variables to store messages and results
iptables_pckage_installed_message=""
iptables_pckage_installed_result="PASS"

# Function to check if iptables and iptables-services are installed
check_iptables_installation() {
  local iptables_result iptables_services_result
  local iptables_output iptables_services_output

  # Check if iptables is installed
  iptables_output=$(rpm -q iptables 2>&1)
  if echo "$iptables_output" | grep -q 'is not installed'; then
    iptables_pckage_installed_message+="FAIL: iptables is not installed\n"
    iptables_result="FAIL"
    iptables_pckage_installed_result="FAIL"
  else
    iptables_pckage_installed_message+="PASS: iptables is installed - $iptables_output\n"
  fi

  # Check if iptables-services is installed
  iptables_services_output=$(rpm -q iptables-services 2>&1)
  if echo "$iptables_services_output" | grep -q 'is not installed'; then
    iptables_pckage_installed_message+="FAIL: iptables-services is not installed\n"
    iptables_services_result="FAIL"
    iptables_pckage_installed_result="FAIL"
  else
    iptables_pckage_installed_message+="PASS: iptables-services is installed - $iptables_services_output\n"
  fi
}

# Run the checks
check_iptables_installation

# 3.4.3.1.2	Ensure nftables is not installed with iptables
# Variables to store messages and results
nftables_installed_iptables_message=""
nftables_installed_iptables_result="PASS"

# Function to check if nftables is not installed
check_nftables_not_installed() {
  local nftables_output

  # Check if nftables is installed
  nftables_output=$(rpm -q nftables 2>&1)
  if echo "$nftables_output" | grep -q 'is not installed'; then
    nftables_installed_iptables_message+="PASS: nftables is not installed\n"
  else
    nftables_installed_iptables_message+="FAIL: nftables is installed - $nftables_output\n"
    nftables_installed_iptables_result="FAIL"
  fi
}

# Run the check
check_nftables_not_installed

# 3.4.3.1.3	Ensure firewalld is either not installed or masked with iptables
# Variables to store messages and results
firewalld_installed_masked_iptables_message=""
firewalld_installed_masked_iptables_result="PASS"

# Function to check if firewalld is not installed
check_firewalld_not_installed() {
  local firewalld_output

  # Check if firewalld is installed
  firewalld_output=$(rpm -q firewalld 2>&1)
  if echo "$firewalld_output" | grep -q 'is not installed'; then
    firewalld_installed_masked_iptables_message+="PASS: firewalld is not installed\n"
  else
    firewalld_installed_masked_iptables_message+="INFO: firewalld is installed - $firewalld_output\n"
  fi
}

# Function to check if firewalld is stopped and masked
check_firewalld_stopped_masked() {
  local firewalld_status firewalld_enabled

  # Check if firewalld is stopped
  firewalld_status=$(systemctl status firewalld | grep "Active: " | grep -v "active (running)")
  if [ -n "$firewalld_status" ]; then
    firewalld_installed_masked_iptables_message+="PASS: firewalld is not active\n"
  else
    firewalld_installed_masked_iptables_message+="FAIL: firewalld is active\n"
    firewalld_installed_masked_iptables_result="FAIL"
  fi

  # Check if firewalld is masked
  firewalld_enabled=$(systemctl is-enabled firewalld 2>&1)
  if echo "$firewalld_enabled" | grep -q 'masked'; then
    firewalld_installed_masked_iptables_message+="PASS: firewalld is masked\n"
  else
    firewalld_installed_masked_iptables_message+="FAIL: firewalld is not masked - $firewalld_enabled\n"
    firewalld_installed_masked_iptables_result="FAIL"
  fi
}

# Run the checks
check_firewalld_not_installed

# Only check if firewalld is stopped and masked if it is installed
if echo "$audit_message" | grep -q 'INFO'; then
  check_firewalld_stopped_masked
fi

# 3.4.3.2.1	Ensure iptables loopback traffic is configured
# Variables to store messages and results
iptables_loopback_traffic_message=""
iptables_loopback_traffic_result="PASS"

# Function to check iptables rules for the INPUT chain
check_iptables_input() {
  local input_rules input_result

  # Get the iptables INPUT chain rules
  input_rules=$(iptables -L INPUT -v -n)

  # Check for the required rules in order
  if echo "$input_rules" | grep -q 'ACCEPT .* lo .* 0.0.0.0/0 .* 0.0.0.0/0' && \
     echo "$input_rules" | grep -q 'DROP .* .* 127.0.0.0/8 .* 0.0.0.0/0'; then
    input_result="PASS"
    iptables_loopback_traffic_message+="PASS: INPUT chain rules are correctly configured\n"
  else
    input_result="FAIL"
    iptables_loopback_traffic_message+="FAIL: INPUT chain rules are not correctly configured\n"
    iptables_loopback_traffic_result="FAIL"
  fi
}

# Function to check iptables rules for the OUTPUT chain
check_iptables_output() {
  local output_rules output_result

  # Get the iptables OUTPUT chain rules
  output_rules=$(iptables -L OUTPUT -v -n)

  # Check for the required rules in order
  if echo "$output_rules" | grep -q 'ACCEPT .* .* lo .* 0.0.0.0/0 .* 0.0.0.0/0'; then
    output_result="PASS"
    iptables_loopback_traffic_message+="PASS: OUTPUT chain rules are correctly configured\n"
  else
    output_result="FAIL"
    iptables_loopback_traffic_message+="FAIL: OUTPUT chain rules are not correctly configured\n"
    iptables_loopback_traffic_result="FAIL"
  fi
}

# Run the checks
check_iptables_input
check_iptables_output

# 3.4.3.2.3	Ensure iptables rules exist for all open ports
# Variables to store messages and results
iptables_rules_exists_message=""
iptables_rules_exists_result="PASS"

# Function to check open ports and firewall rules
check_ports_and_firewall() {
  local open_ports firewall_rules port_check_result

  # Get the list of open ports
  open_ports=$(ss -4tuln | awk 'NR>1 {print $5}' | awk -F: '{print $NF}')

  # Get the iptables INPUT chain rules
  firewall_rules=$(iptables -L INPUT -v -n)

  # Check if each open port has a corresponding firewall rule
  for port in $open_ports; do
    if ! echo "$firewall_rules" | grep -qE "dpt:$port\b"; then
      port_check_result="FAIL"
      iptables_rules_exists_message+="FAIL: No firewall rule found for open port $port\n"
      iptables_rules_exists_result="FAIL"
    fi
  done

  if [ "$port_check_result" != "FAIL" ]; then
    iptables_rules_exists_message+="PASS: All open ports have corresponding firewall rules\n"
  fi
}

# Run the check
check_ports_and_firewall

# 3.4.3.2.4	Ensure iptables default deny firewall policy
# Variables to store messages and results
iptables_default_deny_firewall_policy_message=""
iptables_default_deny_firewall_policy_result="PASS"

# Function to check iptables policies
check_iptables_policies() {
  local input_policy forward_policy output_policy

  # Get the policies for INPUT, FORWARD, and OUTPUT chains
  input_policy=$(iptables -L INPUT | grep "Chain INPUT" | awk '{print $4}')
  forward_policy=$(iptables -L FORWARD | grep "Chain FORWARD" | awk '{print $4}')
  output_policy=$(iptables -L OUTPUT | grep "Chain OUTPUT" | awk '{print $4}')

  # Check if the policies are set to DROP or REJECT
  if [[ "$input_policy" != "DROP" && "$input_policy" != "REJECT" ]]; then
    iptables_default_deny_firewall_policy_message+="FAIL: INPUT chain policy is set to $input_policy\n"
    iptables_default_deny_firewall_policy_result="FAIL"
  else
    iptables_default_deny_firewall_policy_message+="PASS: INPUT chain policy is set to $input_policy\n"
  fi

  if [[ "$forward_policy" != "DROP" && "$forward_policy" != "REJECT" ]]; then
    iptables_default_deny_firewall_policy_message+="FAIL: FORWARD chain policy is set to $forward_policy\n"
    iptables_default_deny_firewall_policy_result="FAIL"
  else
    iptables_default_deny_firewall_policy_message+="PASS: FORWARD chain policy is set to $forward_policy\n"
  fi

  if [[ "$output_policy" != "DROP" && "$output_policy" != "REJECT" ]]; then
    iptables_default_deny_firewall_policy_message+="FAIL: OUTPUT chain policy is set to $output_policy\n"
    iptables_default_deny_firewall_policy_result="FAIL"
  else
    iptables_default_deny_firewall_policy_message+="PASS: OUTPUT chain policy is set to $output_policy\n"
  fi
}

# Run the check
check_iptables_policies

# 3.4.3.2.6	Ensure iptables is enabled and active
# Variables to store messages and results
iptables_enable_active_message=""
iptables_enable_active_result="PASS"

# Check if iptables is enabled
is_enabled=$(systemctl is-enabled iptables 2>/dev/null)
if [ "$is_enabled" == "enabled" ]; then
  iptables_enable_active_message+="iptables is enabled.\n"
else
  iptables_enable_active_message+="iptables is not enabled.\n"
  iptables_enable_active_result="FAIL"
fi

# Check if iptables.service is active
is_active=$(systemctl is-active iptables 2>/dev/null)
if [ "$is_active" == "active" ]; then
  iptables_enable_active_message+="iptables.service is active.\n"
else
  iptables_enable_active_message+="iptables.service is not active.\n"
  iptables_enable_active_result="FAIL"
fi

# 3.4.3.3.1	Ensure ip6tables loopback traffic is configured
# Variables to store messages and results
ip6tables_loopback_traffic_message=""
ip6tables_loopback_traffic_result="PASS"

# Function to check if IPv6 is disabled
check_ipv6_disabled() {
  passing=""
  grubfile=$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)
  ! grep -P -- '^\h*(kernelopts=|linux|kernel)' "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- '^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' && passing="true"
  if [ "$passing" = true ] ; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Check ip6tables rules for INPUT chain
input_check=$(ip6tables -L INPUT -v -n | grep -E 'ACCEPT.*lo.*::/0.*::/0' && ip6tables -L INPUT -v -n | grep -E 'DROP.*::1.*::/0')
if [ -z "$input_check" ]; then
  ip6tables_loopback_traffic_message+="ip6tables INPUT chain does not include the expected rules.\n"
  ip6tables_loopback_traffic_result="FAIL"
else
  ip6tables_loopback_traffic_message+="ip6tables INPUT chain includes the expected rules.\n"
fi

# Check ip6tables rules for OUTPUT chain
output_check=$(ip6tables -L OUTPUT -v -n | grep -E 'ACCEPT.*lo.*::/0.*::/0')
if [ -z "$output_check" ]; then
  ip6tables_loopback_traffic_message+="ip6tables OUTPUT chain does not include the expected rules.\n"
  ip6tables_loopback_traffic_result="FAIL"
else
  ip6tables_loopback_traffic_message+="ip6tables OUTPUT chain includes the expected rules.\n"
fi

# If ip6tables checks failed, check if IPv6 is disabled
if [ "$ip6tables_loopback_traffic_result" == "FAIL" ]; then
  if check_ipv6_disabled; then
    ip6tables_loopback_traffic_message+="IPv6 is disabled on the system.\n"
    ip6tables_loopback_traffic_result="PASS"
  else
    ip6tables_loopback_traffic_message+="IPv6 is enabled on the system.\n"
  fi
fi

# 3.4.3.3.3	Ensure ip6tables firewall rules exist for all open ports
# Variables to store messages and results
ip6tables_firewall_rules_message=""
ip6tables_firewall_rules_result="PASS"

# Function to check if IPv6 is disabled
check_ipv6_disabled() {
  passing=""
  grubfile=$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)
  ! grep -P -- '^\h*(kernelopts=|linux|kernel)' "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- '^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' && passing="true"
  if [ "$passing" = true ] ; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Get open ports
open_ports=$(ss -6tuln)

# Get ip6tables rules
iptables_rules=$(ip6tables -L INPUT -v -n)

# Check open ports against ip6tables rules
while read -r line; do
  protocol=$(echo "$line" | awk '{print $1}')
  port=$(echo "$line" | awk '{print $5}' | awk -F: '{print $2}')
  if [[ "$protocol" == "tcp" || "$protocol" == "udp" ]]; then
    rule_check=$(echo "$iptables_rules" | grep "$protocol dpt:$port")
    if [ -z "$rule_check" ]; then
      ip6tables_firewall_rules_message+="No firewall rule for open port $port ($protocol).\n"
      ip6tables_firewall_rules_result="FAIL"
    else
      ip6tables_firewall_rules_message+="Firewall rule exists for open port $port ($protocol).\n"
    fi
  fi
done <<< "$open_ports"

# If the check fails, verify if IPv6 is disabled
if [ "$ip6tables_firewall_rules_result" == "FAIL" ]; then
  if check_ipv6_disabled; then
    ip6tables_firewall_rules_message+="IPv6 is disabled on the system.\n"
    ip6tables_firewall_rules_result="PASS"
  else
    ip6tables_firewall_rules_message+="IPv6 is enabled on the system.\n"
  fi
fi

# 3.4.3.3.4	Ensure ip6tables default deny firewall policy
# Variables to store messages and results
ip6tables_default_deny_firewall_message=""
ip6tables_default_deny_firewall_result="PASS"

# Function to check if IPv6 is disabled
check_ipv6_disabled() {
  passing=""
  grubfile=$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)
  ! grep -P -- '^\h*(kernelopts=|linux|kernel)' "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- '^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' && passing="true"
  if [ "$passing" = true ] ; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Check ip6tables policies
iptables_policies=$(ip6tables -L)

input_policy=$(echo "$iptables_policies" | grep "Chain INPUT" | awk '{print $4}')
forward_policy=$(echo "$iptables_policies" | grep "Chain FORWARD" | awk '{print $4}')
output_policy=$(echo "$iptables_policies" | grep "Chain OUTPUT" | awk '{print $4}')

if [[ "$input_policy" == "DROP" || "$input_policy" == "REJECT" ]] &&
   [[ "$forward_policy" == "DROP" || "$forward_policy" == "REJECT" ]] &&
   [[ "$output_policy" == "DROP" || "$output_policy" == "REJECT" ]]; then
  ip6tables_default_deny_firewall_message+="The policy for the INPUT, FORWARD, and OUTPUT chains is $input_policy.\n"
else
  ip6tables_default_deny_firewall_message+="The policy for one or more of the INPUT, FORWARD, and OUTPUT chains is not DROP or REJECT.\n"
  ip6tables_default_deny_firewall_result="FAIL"
fi

# If the check fails, verify if IPv6 is disabled
if [ "$ip6tables_default_deny_firewall_result" == "FAIL" ]; then
  if check_ipv6_disabled; then
    ip6tables_default_deny_firewall_message+="IPv6 is disabled on the system.\n"
    ip6tables_default_deny_firewall_result="PASS"
  else
    ip6tables_default_deny_firewall_message+="IPv6 is enabled on the system.\n"
  fi
fi

# 3.4.3.3.5	Ensure ip6tables rules are saved
# Variables to store messages and results
ip6tables_rule_saved_message=""
ip6tables_rule_saved_result="PASS"

# Function to check if IPv6 is disabled
check_ipv6_disabled() {
  passing=""
  grubfile=$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)
  ! grep -P -- '^\h*(kernelopts=|linux|kernel)' "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- '^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' && passing="true"
  if [ "$passing" = true ] ; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Function to check the ip6tables rule-set
check_ip6tables_rules() {
  correct_rules="*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -s ::1/128 -j DROP
-A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
-A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
-A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -m state --state NEW -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
-A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
-A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT
COMMIT"

  ip6tables_rules=$(cat /etc/sysconfig/ip6tables)

  if [[ "$ip6tables_rules" == "$correct_rules" ]]; then
    ip6tables_rule_saved_message+="The ip6tables rule-set is correct.\n"
    return 0
  else
    ip6tables_rule_saved_message+="The ip6tables rule-set is incorrect.\n"
    return 1
  fi
}

# Check the ip6tables rule-set
if check_ip6tables_rules; then
  ip6tables_rule_saved_result="PASS"
else
  ip6tables_rule_saved_result="FAIL"
fi

# If the check fails, verify if IPv6 is disabled
if [ "$ip6tables_rule_saved_result" == "FAIL" ]; then
  if check_ipv6_disabled; then
    ip6tables_rule_saved_message+="IPv6 is disabled on the system.\n"
    ip6tables_rule_saved_result="PASS"
  else
    ip6tables_rule_saved_message+="IPv6 is enabled on the system.\n"
  fi
fi

# 3.4.3.3.6	Ensure ip6tables is enabled and active
# Variables to store messages and results
ip6tables_enabled_active_message=""
ip6tables_enabled_active_result="PASS"

# Function to check if IPv6 is disabled
check_ipv6_disabled() {
  passing=""
  grubfile=$(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;)
  ! grep -P -- '^\h*(kernelopts=|linux|kernel)' "$grubfile" | grep -vq -- ipv6.disable=1 && passing="true"
  grep -Pq -- '^\s*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' /etc/sysctl.conf /etc/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /run/sysctl.d/*.conf && \
  sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\h*(#.*)?$' && \
  sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pq -- '^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\h*(#.*)?$' && passing="true"
  if [ "$passing" = true ] ; then
    echo -e "\nIPv6 is disabled on the system\n"
    return 0
  else
    echo -e "\nIPv6 is enabled on the system\n"
    return 1
  fi
}

# Function to check if ip6tables is enabled and active
check_ip6tables_status() {
  enabled_status=$(systemctl is-enabled ip6tables)
  active_status=$(systemctl is-active ip6tables)

  if [ "$enabled_status" == "enabled" ] && [ "$active_status" == "active" ]; then
    ip6tables_enabled_active_message+="ip6tables is enabled and active.\n"
    return 0
  else
    ip6tables_enabled_active_message+="ip6tables is not enabled or not active.\n"
    return 1
  fi
}

# Check ip6tables status
if check_ip6tables_status; then
  ip6tables_enabled_active_result="PASS"
else
  ip6tables_enabled_active_result="FAIL"
fi

# If the check fails, verify if IPv6 is disabled
if [ "$ip6tables_enabled_active_result" == "FAIL" ]; then
  if check_ipv6_disabled; then
    ip6tables_enabled_active_message+="IPv6 is disabled on the system.\n"
    ip6tables_enabled_active_result="PASS"
  else
    ip6tables_enabled_active_message+="IPv6 is enabled on the system.\n"
  fi
fi

# 4.2.3	Ensure permissions on all logfiles are configured
# Variables to store messages and results
permission_logfiles_message=""
permission_logfiles_result="PASS"

# Function to check file permissions in /var/log/
check_permissions() {
  # Find files in /var/log/ with group write or execute permissions, or others read, write, or execute permissions
  bad_permissions=$(find /var/log/ -type f -perm /g+wx,o+rwx -exec ls -l "{}" +)

  if [ -z "$bad_permissions" ]; then
    permission_logfiles_message+="No files in /var/log/ have group write/execute or others read/write/execute permissions.\n"
    return 0
  else
    permission_logfiles_message+="The following files have improper permissions:\n$bad_permissions\n"
    return 1
  fi
}

# Check permissions
if check_permissions; then
  permission_logfiles_result="PASS"
else
  permission_logfiles_result="FAIL"
fi

# 4.2.1.1	Ensure rsyslog is installed
# Variables to store messages and results
rsyslog_installed_message=""
rsyslog_installed_result="PASS"

# Function to check if rsyslog is installed
check_rsyslog_installed() {
  # Run the command to check rsyslog installation
  rsyslog_output=$(rpm -q rsyslog)

  # Check if the output matches the expected pattern
  if [[ $rsyslog_output =~ rsyslog-[0-9]+\.[0-9]+\.[0-9]+ ]]; then
    rsyslog_installed_message+="rsyslog is installed: $rsyslog_output\n"
    return 0
  else
    rsyslog_installed_message+="rsyslog is not installed or the output does not match the expected pattern.\n"
    rsyslog_installed_message+="Output: $rsyslog_output\n"
    return 1
  fi
}

# Check rsyslog installation
if check_rsyslog_installed; then
  rsyslog_installed_result="PASS"
else
  rsyslog_installed_result="FAIL"
fi

# 4.2.1.2	Ensure rsyslog service is enabled
# Variables to store messages and results
rsyslog_service_enabled_message=""
rsyslog_service_enabled_result="PASS"

# Function to check if rsyslog is enabled
check_rsyslog_enabled() {
  # Run the command to check if rsyslog is enabled
  rsyslog_enabled_output=$(systemctl is-enabled rsyslog)

  # Check if the output matches the expected value
  if [[ $rsyslog_enabled_output == "enabled" ]]; then
    rsyslog_service_enabled_message+="rsyslog is enabled: $rsyslog_enabled_output\n"
    return 0
  else
    rsyslog_service_enabled_message+="rsyslog is not enabled. Output: $rsyslog_enabled_output\n"
    return 1
  fi
}

# Check if rsyslog is enabled
if check_rsyslog_enabled; then
  rsyslog_service_enabled_result="PASS"
else
  rsyslog_service_enabled_result="FAIL"
fi

# 4.2.1.4	Ensure rsyslog default file permissions are configured
# Variables to store messages and results
rsyslog_default_file_permission_message=""
rsyslog_default_file_permission_result="PASS"

# Function to check the FileCreateMode in rsyslog configuration
check_file_create_mode() {
  # Run the command to check FileCreateMode
  file_create_mode_output=$(grep ^\$FileCreateMode /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)

  # Check if the output matches the expected value
  if echo "$file_create_mode_output" | grep -q "\$FileCreateMode 0640"; then
    rsyslog_default_file_permission_message+="FileCreateMode is set correctly: $file_create_mode_output\n"
    return 0
  elif echo "$file_create_mode_output" | grep -q "\$FileCreateMode 0600"; then
    rsyslog_default_file_permission_message+="FileCreateMode is set more restrictively to 0600: $file_create_mode_output\n"
    return 0
  else
    rsyslog_default_file_permission_message+="FileCreateMode is not set correctly. Output: $file_create_mode_output\n"
    return 1
  fi
}

# Check the FileCreateMode in rsyslog configuration
if check_file_create_mode; then
  rsyslog_default_file_permission_result="PASS"
else
  rsyslog_default_file_permission_result="FAIL"
fi

# 4.2.1.7	Ensure rsyslog is not configured to recieve logs from a remote client
# Variables to store messages and results
rsyslog_not_configured_receive_log_message=""
rsyslog_not_configured_receive_log_result="PASS"

# Function to check the old format for incoming logs
check_old_format() {
  # Run the commands to check the old format
  modload_output=$(grep '\$ModLoad imtcp' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
  inputtcpserverrun_output=$(grep '\$InputTCPServerRun' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)

  # Check if there is any output
  if [ -n "$modload_output" ] || [ -n "$inputtcpserverrun_output" ]; then
    rsyslog_not_configured_receive_log_message+="Old format configuration found for accepting incoming logs:\n"
    [ -n "$modload_output" ] && rsyslog_not_configured_receive_log_message+="$modload_output\n"
    [ -n "$inputtcpserverrun_output" ] && rsyslog_not_configured_receive_log_message+="$inputtcpserverrun_output\n"
    return 1
  else
    rsyslog_not_configured_receive_log_message+="No old format configuration found for accepting incoming logs.\n"
    return 0
  fi
}

# Function to check the new format for incoming logs
check_new_format() {
  # Run the commands to check the new format
  module_output=$(grep -P -- '^\h*module\(load="imtcp"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
  input_output=$(grep -P -- '^\h*input\(type="imtcp" port="514"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)

  # Check if there is any output
  if [ -n "$module_output" ] || [ -n "$input_output" ]; then
    rsyslog_not_configured_receive_log_message+="New format configuration found for accepting incoming logs:\n"
    [ -n "$module_output" ] && rsyslog_not_configured_receive_log_message+="$module_output\n"
    [ -n "$input_output" ] && rsyslog_not_configured_receive_log_message+="$input_output\n"
    return 1
  else
    rsyslog_not_configured_receive_log_message+="No new format configuration found for accepting incoming logs.\n"
    return 0
  fi
}

# Check both old and new formats
if check_old_format && check_new_format; then
  rsyslog_not_configured_receive_log_result="PASS"
else
  rsyslog_not_configured_receive_log_result="FAIL"
fi

# 4.2.2.2	Ensure journald service is enabled
# Variables to store messages and results
journald_enabled_message=""
journald_enabled_result="PASS"

# Function to check if systemd-journald is enabled
check_systemd_journald_enabled() {
  # Run the command to check if systemd-journald is enabled
  is_enabled_output=$(systemctl is-enabled systemd-journald.service 2>/dev/null)

  # Check if the output matches "static"
  if [ "$is_enabled_output" == "static" ]; then
    journald_enabled_message+="systemd-journald is enabled and the output matches 'static'.\n"
    return 0
  else
    journald_enabled_message+="systemd-journald is not enabled or the output does not match 'static'. Output: $is_enabled_output\n"
    return 1
  fi
}

# Check systemd-journald enabled status
if check_systemd_journald_enabled; then
  journald_enabled_result="PASS"
else
  journald_enabled_result="FAIL"
fi

# 4.2.2.3	Ensure journald is configured to compress large log files
# Define variables for audit message and result
journald_configured_compress_message=""
journald_configured_compress_result="Pass"

# Check if the Compress option is set in /etc/systemd/journald.conf
compress_setting=$(grep '^\s*Compress' /etc/systemd/journald.conf | awk -F '=' '{gsub(/[ \t]+$/, "", $2); print $2}')

# Check if the setting matches 'yes'
if [[ "$compress_setting" == "yes" ]]; then
    journald_configured_compress_message="Compress setting is correctly configured."
else
    journald_configured_compress_message="Compress setting is not configured to 'yes'."
    journald_configured_compress_result="Fail"
fi

# 4.2.2.4	Ensure journald is configured to write logfiles to persistent disk
# Define variables for audit message and result
journald_configured_write_log_message=""
journald_configured_write_log_result="Pass"

# Check if the Storage option is set in /etc/systemd/journald.conf
storage_setting=$(grep '^\s*Storage' /etc/systemd/journald.conf | awk -F '=' '{gsub(/[ \t]+$/, "", $2); print $2}')

# Check if the setting matches 'persistent'
if [[ "$storage_setting" == "persistent" ]]; then
    journald_configured_write_log_message="Storage setting is correctly configured."
else
    journald_configured_write_log_message="Storage setting is not configured to 'persistent'."
    journald_configured_write_log_result="Fail"
fi

# 4.2.2.1.4	Ensure journald is not configured to recieve logs from a remote client
# Define variables for audit message and result
journald_configured_receive_log_message=""
journald_configured_receive_log_result="Pass"

# Check if systemd-journal-remote.socket is enabled
socket_status=$(systemctl is-enabled systemd-journal-remote.socket 2>/dev/null)

# Check if the status matches 'masked'
if [[ "$socket_status" == "masked" ]]; then
    journald_configured_receive_log_message="systemd-journal-remote.socket is correctly masked (not enabled)."
else
    journald_configured_receive_log_message="systemd-journal-remote.socket is not masked (may be enabled or another status)."
    journald_configured_receive_log_result="Fail"
fi

# 5.1.1	Ensure cron daemon is enabled
# Variables to store messages and results
cron_daeemon_enabled_message=""
cron_daeemon_enabled_result="PASS"

# Function to check if crond is enabled
check_crond_enabled() {
  # Run the command to check if crond is enabled
  is_enabled_output=$(systemctl is-enabled crond 2>/dev/null)

  # Check if the output matches "enabled"
  if [ "$is_enabled_output" == "enabled" ]; then
    cron_daeemon_enabled_message+="crond is enabled and the output matches 'enabled'.\n"
    return 0
  else
    cron_daeemon_enabled_message+="crond is not enabled or the output does not match 'enabled'. Output: $is_enabled_output\n"
    return 1
  fi
}

# Check crond enabled status
if check_crond_enabled; then
  cron_daeemon_enabled_result="PASS"
else
  cron_daeemon_enabled_result="FAIL"
fi

# 5.1.2	Ensure permissions on /etc/crontab are configured
# Define variables for audit message and result
crontab_permission_configured_message=""
crontab_permission_configured_result="Pass"

# Get the stat information of /etc/crontab
stat_output=$(stat /etc/crontab)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    crontab_permission_configured_message="Permissions, UID, and GID of /etc/crontab are correctly configured."
else
    crontab_permission_configured_message="Permissions, UID, or GID of /etc/crontab are not correctly configured."
    crontab_permission_configured_result="Fail"
fi

#   5.1.3	Ensure permissions on /etc/cron.hourly are configured
# Define variables for audit message and result
cronHourly_permission_configured_message=""
cronHourly_permission_configured_result="Pass"

# Get the stat information of /etc/cron.hourly
stat_output=$(stat /etc/cron.hourly)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    cronHourly_permission_configured_message="Permissions, UID, and GID of /etc/cron.hourly are correctly configured."
else
    cronHourly_permission_configured_message="Permissions, UID, or GID of /etc/cron.hourly are not correctly configured."
    cronHourly_permission_configured_result="Fail"
fi

# 5.1.4	Ensure permissions on /etc/cron.daily are configured
# Define variables for audit message and result
cronDaily_permission_configured_message=""
cronDaily_permission_configured_result="Pass"

# Get the stat information of /etc/cron.hourly
stat_output=$(stat /etc/cron.daily)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    cronDaily_permission_configured_message="Permissions, UID, and GID of /etc/cron.daily are correctly configured."
else
    cronDaily_permission_configured_message="Permissions, UID, or GID of /etc/cron.daily are not correctly configured."
    cronDaily_permission_configured_result="Fail"
fi

# 5.1.5	Ensure permissions on /etc/cron.weekly are configured
# Define variables for audit message and result
cronWeekly_permission_configured_message=""
cronWeekly_permission_configured_result="Pass"

# Get the stat information of /etc/cron.hourly
stat_output=$(stat /etc/cron.weekly)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    cronWeekly_permission_configured_message="Permissions, UID, and GID of /etc/cron.weekly are correctly configured."
else
    cronWeekly_permission_configured_message="Permissions, UID, or GID of /etc/cron.weekly are not correctly configured."
    cronWeekly_permission_configured_result="Fail"
fi

# 5.1.6	Ensure permissions on /etc/cron.monthly are configured

# Define variables for audit message and result
cronMonthly_permission_configured_message=""
cronMonthly_permission_configured_result="Pass"

# Get the stat information of /etc/cron.hourly
stat_output=$(stat /etc/cron.monthly)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    cronMonthly_permission_configured_message="Permissions, UID, and GID of /etc/cron.monthly are correctly configured."
else
    cronMonthly_permission_configured_message="Permissions, UID, or GID of /etc/cron.monthly are not correctly configured."
    cronMonthly_permission_configured_result="Fail"
fi

# 5.1.7	Ensure permissions on /etc/cron.d are configured
# Define variables for audit message and result
cronD_permission_configured_message=""
cronD_permission_configured_result="Pass"

# Get the stat information of /etc/cron.hourly
stat_output=$(stat /etc/cron.d)

# Extract the relevant line with Access, Uid, and Gid
access_line=$(echo "$stat_output" | grep 'Access: (')

# Define the expected output for comparison
expected_output="Access: (0700/drwx------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the extracted line with the expected output
if [[ "$access_line" == "$expected_output" ]]; then
    cronD_permission_configured_message="Permissions, UID, and GID of /etc/cron.d are correctly configured."
else
    cronD_permission_configured_message="Permissions, UID, or GID of /etc/cron.d are not correctly configured."
    cronD_permission_configured_result="Fail"
fi

# 5.1.8	Ensure cron is restricted to authorized users
# Define variables for audit message and result
cron_restricted_authorized_user_message=""
cron_restricted_authorized_user_result="Fail"

# Function to check cron configuration and store audit messages
cron_chk() {
    local messages=()
    
    if rpm -q cronie >/dev/null; then
        [ -e /etc/cron.deny ] && messages+=("Fail: cron.deny exists")
        
        if [ ! -e /etc/cron.allow ]; then
            messages+=("Fail: cron.allow doesn't exist")
        else
            ! stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" && messages+=("Fail: cron.allow mode too permissive")
            ! stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$" && messages+=("Fail: cron.allow owner and/or group not root")
        fi
        
        if [ ! -e /etc/cron.deny ] && [ -e /etc/cron.allow ] && stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" \
            && stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$"; then
            messages+=("Pass")
        fi
    else
        messages+=("Pass: cron is not installed on the system")
    fi
    
    # Print all messages stored in the array
    printf "%s\n" "${messages[@]}"
}

# Run the cron_chk function and capture the output
script_output=$(cron_chk)

# Store script_output in cron_restricted_authorized_user_message
cron_restricted_authorized_user_message="$script_output"

# Check if the output contains "Pass"
if [[ "$script_output" == *"Pass"* ]]; then
    cron_restricted_authorized_user_result="Pass"
fi

# 5.1.9	Ensure at is restricted to authorized users
# Define variables for audit message and result
at_restricted_authorized_user_message=""
at_restricted_authorized_user_result="Fail"

# Function to check at configuration and store audit messages
at_chk() {
    local messages=()
    
    if rpm -q at >/dev/null; then
        [ -e /etc/at.deny ] && messages+=("Fail: at.deny exists")
        
        if [ ! -e /etc/at.allow ]; then
            messages+=("Fail: at.allow doesn't exist")
        else
            ! stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" && messages+=("Fail: at.allow mode too permissive")
            ! stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$" && messages+=("Fail: at.allow owner and/or group not root")
        fi
        
        if [ ! -e /etc/at.deny ] && [ -e /etc/at.allow ] && stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" \
            && stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$"; then
            messages+=("Pass")
        fi
    else
        messages+=("Pass: at is not installed on the system")
    fi
    
    # Print all messages stored in the array
    printf "%s\n" "${messages[@]}"
}

# Run the at_chk function and capture the output
script_output=$(at_chk)

# Store script_output in at_restricted_authorized_user_message
at_restricted_authorized_user_message="$script_output"

# Check if the output contains "Pass"
if [[ "$script_output" == *"Pass"* ]]; then
    at_restricted_authorized_user_result="Pass"
fi

# 5.2.1	Ensure permissions on /etc/ssh/sshd_config are configured
# Variables to store messages and results
sshd_config_permission_configured_message=""
sshd_config_permission_configured_result="PASS"

# Function to check the ownership and permissions of /etc/ssh/sshd_config
check_sshd_config_permissions() {
  # Get the stat output of /etc/ssh/sshd_config
  stat_output=$(stat /etc/ssh/sshd_config 2>/dev/null)

  # Expected output
  expected_output="Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)"

  # Compare the actual stat output to the expected output
  if echo "$stat_output" | grep -q "$expected_output"; then
    sshd_config_permission_configured_message+="Permissions and ownership for /etc/ssh/sshd_config are correct.\n"
  else
    sshd_config_permission_configured_message+="Permissions and ownership for /etc/ssh/sshd_config are incorrect.\n"
    sshd_config_permission_configured_result="FAIL"
  fi
}

# Run the check
check_sshd_config_permissions

# 5.2.2	Ensure permissions on SSH private host key files are configured
# Variables to store messages and results
sshd_private_key_configured_message=""
sshd_private_key_configured_result="PASS"

# Function to check the ownership and permissions of SSH host key files
check_ssh_private_key_permissions() {
  # Get the list of SSH host key files
  key_files=$(find /etc/ssh -xdev -type f -name 'ssh_host_*_key')

  # Iterate through each key file and check its permissions and ownership
  for key_file in $key_files; do
    key_permissions=$(stat -c "%a" "$key_file")
    key_owner=$(stat -c "%U" "$key_file")
    key_group=$(stat -c "%G" "$key_file")
    
    if [ "$key_owner" = "root" ]; then
        if [ "$key_permissions" -eq "600" ] && [ "$key_group" = "root" ]; then
            sshd_private_key_configured_message+="Pass: Permissions and ownership for $key_file are correct\n"
        elif [ "$key_permissions" -eq "640" ] && [ "$key_group" = "ssh_keys" ]; then
            sshd_private_key_configured_message+="Pass: Permissions and ownership for $key_file are correct\n"
        else
            sshd_private_key_configured_message+="Fail: Permissions or group for $key_file are incorrect\n"
            sshd_private_key_configured_message+="Actual permissions: $key_permissions, Owner: $key_owner, Group: $key_group\n"
            sshd_private_key_configured_result="FAIL"
        fi
    else
        sshd_private_key_configured_message+="Fail: Owner of $key_file is not root\n"
        sshd_private_key_configured_message+="Actual owner: $key_owner\n"
        sshd_private_key_configured_result="FAIL"
    fi
  done

  # If no key files found, set appropriate message and result
  if [ -z "$key_files" ]; then
    sshd_private_key_configured_message+="Fail: No SSH host key files found.\n"
    sshd_private_key_configured_result="FAIL"
  fi
}

# Run the check
check_ssh_private_key_permissions

# 5.2.3	Ensure permissions on SSH public host key files are configured
# Variables to store messages and results
ssh_public_key_configured_message=""
ssh_public_key_configured_result="PASS"

# Function to check the permissions of SSH public host key files
check_ssh_public_key_permissions() {
  # Get the list of SSH public key files
  pub_key_files=$(find /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub')

  # Iterate through each public key file and check its permissions
  for pub_key_file in $pub_key_files; do
    key_permissions=$(stat -c "%a" "$pub_key_file")
    key_owner=$(stat -c "%U" "$pub_key_file")
    key_group=$(stat -c "%G" "$pub_key_file")

    if [ "$key_permissions" -le "644" ] && [ "$key_owner" = "root" ] && [ "$key_group" = "root" ]; then
      ssh_public_key_configured_message+="Pass: Permissions on $pub_key_file are configured correctly\n"
    else
      ssh_public_key_configured_message+="Fail: Permissions on $pub_key_file are not configured correctly\n"
      ssh_public_key_configured_message+="Actual permissions: $key_permissions, Owner: $key_owner, Group: $key_group\n"
      ssh_public_key_configured_result="FAIL"
    fi
  done

  # If no public key files found, set appropriate message and result
  if [ -z "$pub_key_files" ]; then
    ssh_public_key_configured_message+="Fail: No SSH public key files found.\n"
    ssh_public_key_configured_result="FAIL"
  fi
}

# Run the check
check_ssh_public_key_permissions

# 5.2.4	Ensure SSH access is limited
# Define variables for audit message and result
ssh_access_limited_message=""
ssh_access_limited_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Pi '^\h*(allow|deny)(users|groups)\h+\H+(\h+.*)?$' /etc/ssh/sshd_config)

# Define patterns to match in the output
expected_pattern1="allowusers"
expected_pattern2="allowgroups"
expected_pattern3="denyusers"
expected_pattern4="denygroups"

# Check if either command output matches the expected patterns
if [[ "$command1_output" =~ $expected_pattern1 ]] || [[ "$command1_output" =~ $expected_pattern2 ]] ||
   [[ "$command1_output" =~ $expected_pattern3 ]] || [[ "$command1_output" =~ $expected_pattern4 ]] ||
   [[ "$command2_output" =~ $expected_pattern1 ]] || [[ "$command2_output" =~ $expected_pattern2 ]] ||
   [[ "$command2_output" =~ $expected_pattern3 ]] || [[ "$command2_output" =~ $expected_pattern4 ]]; then
    ssh_access_limited_result="Pass"
    ssh_access_limited_message="Audit passed: The sshd configuration matches the expected patterns."
else
    ssh_access_limited_message="Audit failed: The sshd configuration does not match the expected patterns."
fi

# 5.2.5	Ensure SSH LogLevel is appropriate
# Define variables for audit message and result
ssh_loglevel_appropriate_message=""
ssh_loglevel_appropriate_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -i 'loglevel' /etc/ssh/sshd_config | grep -Evi '(VERBOSE|INFO)')

# Define patterns to match in the output
expected_pattern1="loglevel VERBOSE"
expected_pattern2="loglevel INFO"

# Check if command 1 output matches expected patterns
if [[ "$command1_output" =~ $expected_pattern1 ]] || [[ "$command1_output" =~ $expected_pattern2 ]]; then
    ssh_loglevel_appropriate_message+="Command 1: SSHD configuration matches 'loglevel VERBOSE' or 'loglevel INFO'. \n"
else
    ssh_loglevel_appropriate_message+="Command 1: SSHD configuration does not match 'loglevel VERBOSE' or 'loglevel INFO'.\n "
fi

# Check if command 2 output is empty (no matches for 'loglevel' other than 'VERBOSE' or 'INFO')
if [ -z "$command2_output" ]; then
    ssh_loglevel_appropriate_message+="Command 2: No lines found in /etc/ssh/sshd_config that violate 'loglevel VERBOSE' or 'loglevel INFO'.\n"
else
    ssh_loglevel_appropriate_message+="Command 2: Found lines in /etc/ssh/sshd_config that do not match 'loglevel VERBOSE' or 'loglevel INFO'.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern1 || "$command1_output" =~ $expected_pattern2 ]] && [ -z "$command2_output" ]; then
    ssh_loglevel_appropriate_result="Pass"
else
    ssh_loglevel_appropriate_result="Fail"
fi

# 5.2.6	Ensure SSH PAM is enabled
# Define variables for audit message and result
ssh_PAM_enable_message=""
ssh_PAM_enable_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*UsePAM\s+no' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="usepam yes"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_PAM_enable_message+="Command 1: SSHD configuration matches 'usepam yes'. \n"
else
    ssh_PAM_enable_message+="Command 1: SSHD configuration does not match 'usepam yes'.\n "
fi

# Check if command 2 output is empty (no 'UsePAM no' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_PAM_enable_message+="Command 2: No 'UsePAM no' found in /etc/ssh/sshd_config.\n"
else
    ssh_PAM_enable_message+="Command 2: Found 'UsePAM no' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_PAM_enable_result="Pass"
else
    ssh_PAM_enable_result="Fail"
fi

# 5.2.7	Ensure SSH root login is disabled
# Define variables for audit message and result
ssh_root_login_message=""
ssh_root_login_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*PermitRootLogin\s+yes' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="permitrootlogin no"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_root_login_message+="Command 1: SSHD configuration matches 'permitrootlogin no'. \n"
else
    ssh_root_login_message+="Command 1: SSHD configuration does not match 'permitrootlogin no'. \n"
fi

# Check if command 2 output is empty (no 'PermitRootLogin yes' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_root_login_message+="Command 2: No 'PermitRootLogin yes' found in /etc/ssh/sshd_config.\n"
else
    ssh_root_login_message+="Command 2: Found 'PermitRootLogin yes' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_root_login_result="Pass"
else
    ssh_root_login_result="Fail"
fi

# 5.2.8	Ensure SSH HostbasedAuthentication is disabled
# Define variables for audit message and result
ssh_hostBasedAuthentication_message=""
ssh_hostBasedAuthentication_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*HostbasedAuthentication\s+yes' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="hostbasedauthentication no"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_hostBasedAuthentication_message+="Command 1: SSHD configuration matches 'hostbasedauthentication no'.\n "
else
    ssh_hostBasedAuthentication_message+="Command 1: SSHD configuration does not match 'hostbasedauthentication no'.\n "
fi

# Check if command 2 output is empty (no 'HostbasedAuthentication yes' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_hostBasedAuthentication_message+="Command 2: No 'HostbasedAuthentication yes' found in /etc/ssh/sshd_config.\n"
else
    ssh_hostBasedAuthentication_message+="Command 2: Found 'HostbasedAuthentication yes' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_hostBasedAuthentication_result="Pass"
else
    ssh_hostBasedAuthentication_result="Fail"
fi

# 5.2.9	Ensure SSH PermitEmptyPasswords is disabled
# Define variables for audit message and result
ssh_PermitEmptyPassword_message=""
ssh_PermitEmptyPassword_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*PermitEmptyPasswords\s+yes' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="permitemptypasswords no"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_PermitEmptyPassword_message+="Command 1: SSHD configuration matches 'permitemptypasswords no'.\n "
else
    ssh_PermitEmptyPassword_message+="Command 1: SSHD configuration does not match 'permitemptypasswords no'. \n"
fi

# Check if command 2 output is empty (no 'PermitEmptyPasswords yes' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_PermitEmptyPassword_message+="Command 2: No 'PermitEmptyPasswords yes' found in /etc/ssh/sshd_config.\n"
else
    ssh_PermitEmptyPassword_message+="Command 2: Found 'PermitEmptyPasswords yes' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_PermitEmptyPassword_result="Pass"
else
    ssh_PermitEmptyPassword_result="Fail"
fi

#   5.2.10	Ensure SSH PermitUserEnvironment is disabled
# Define variables for audit message and result
ssh_PermitUserEnvironment_message=""
ssh_PermitUserEnvironment_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*PermitUserEnvironment\s+yes' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="permituserenvironment no"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_PermitUserEnvironment_message+="Command 1: SSHD configuration matches 'permituserenvironment no'.\n "
else
    ssh_PermitUserEnvironment_message+="Command 1: SSHD configuration does not match 'permituserenvironment no'.\n "
fi

# Check if command 2 output is empty (no 'PermitUserEnvironment yes' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_PermitUserEnvironment_message+="Command 2: No 'PermitUserEnvironment yes' found in /etc/ssh/sshd_config.\n"
else
    ssh_PermitUserEnvironment_message+="Command 2: Found 'PermitUserEnvironment yes' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_PermitUserEnvironment_result="Pass"
else
    ssh_PermitUserEnvironment_result="Fail"
fi

# 5.2.11	Ensure SSH IgnoreRhosts is enabled
# Define variables for audit message and result
ssh_IgnoreRhosts_message=""
ssh_IgnoreRhosts_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command1_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*ignorerhosts\s+no\b' /etc/ssh/sshd_config)

# Define expected pattern for Command 1
expected_pattern="ignorerhosts yes"

# Check if command 1 output matches expected pattern
if [[ "$command1_output" =~ $expected_pattern ]]; then
    ssh_IgnoreRhosts_message+="Command 1: SSHD configuration matches 'ignorerhosts yes'.\n "
else
    ssh_IgnoreRhosts_message+="Command 1: SSHD configuration does not match 'ignorerhosts yes'. \n"
fi

# Check if command 2 output is empty (no 'ignorerhosts no' found in sshd_config)
if [ -z "$command2_output" ]; then
    ssh_IgnoreRhosts_message+="Command 2: No 'ignorerhosts no' found in /etc/ssh/sshd_config.\n"
else
    ssh_IgnoreRhosts_message+="Command 2: Found 'ignorerhosts no' in /etc/ssh/sshd_config.\n"
fi

# Check overall audit result
if [[ "$command1_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_IgnoreRhosts_result="Pass"
else
    ssh_IgnoreRhosts_result="Fail"
fi

# 5.2.14	Ensure system-wide crypto policy is not over-ridden
# Define variables for audit message and result
system_wide_crypto_policy_message=""
system_wide_crypto_policy_result="Fail"

# Command: Check the value of CRYPTO_POLICY in /etc/sysconfig/sshd
command_output=$(grep -i '^\s*CRYPTO_POLICY=' /etc/sysconfig/sshd)

# Check if command output is empty (no 'CRYPTO_POLICY=' line found)
if [ -z "$command_output" ]; then
    system_wide_crypto_policy_message="No 'CRYPTO_POLICY=' found in /etc/sysconfig/sshd.\n"
    system_wide_crypto_policy_result="Pass"
else
    system_wide_crypto_policy_message="Found 'CRYPTO_POLICY=' in /etc/sysconfig/sshd.\n"
    system_wide_crypto_policy_result="Fail"
fi

# 5.2.15	Ensure SSH warning banner is configured
# Define variables for audit message and result
ssh_warning_banner_message=""
ssh_warning_banner_result="Fail"

# Command: Check sshd configuration using sshd -T
command_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')")

# Define expected pattern for Command 1
expected_pattern="banner /etc/issue.net"

# Check if command output contains expected pattern
if [[ "$command_output" =~ $expected_pattern ]]; then
    ssh_warning_banner_message+="SSHD configuration matches 'banner /etc/issue.net'. \n"
    ssh_warning_banner_result="Pass"
else
    ssh_warning_banner_message+="SSHD configuration does not match 'banner /etc/issue.net'.\n "
    ssh_warning_banner_result="Fail"
fi

# 5.2.16	Ensure SSH MaxAuthTries is set to 4 or less
# Define variables for audit message and result
ssh_MaxAuthTries_message=""
ssh_MaxAuthTries_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep maxauthtries)

# Define expected pattern for Command 1
expected_pattern="maxauthtries 4"

# Check if command output contains expected pattern
if [[ "$command_output" =~ $expected_pattern ]]; then
    ssh_MaxAuthTries_message+="SSHD configuration matches 'maxauthtries 4'.\n "
else
    ssh_MaxAuthTries_message+="SSHD configuration does not match 'maxauthtries 4'.\n "
fi

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*maxauthtries\s+([5-9]|[1-9][0-9]+)' /etc/ssh/sshd_config)

# Check if command 2 output is empty (no lines matching high MaxAuthTries values)
if [ -z "$command2_output" ]; then
    ssh_MaxAuthTries_message+="No high 'MaxAuthTries' values found in /etc/ssh/sshd_config.\n"
else
    ssh_MaxAuthTries_message+="Found high 'MaxAuthTries' values in /etc/ssh/sshd_config.\n"
    ssh_MaxAuthTries_result="Fail"
fi

# Check overall audit result
if [[ "$command_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_MaxAuthTries_result="Pass"
else
    ssh_MaxAuthTries_result="Fail"
fi

# 5.2.17	Ensure SSH MaxStartups is configured
# Define variables for audit message and result
ssh_MaxStartups_message=""
ssh_MaxStartups_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i maxstartups)

# Define expected pattern for Command 1
expected_pattern="maxstartups 10:30:60"

# Check if command output contains expected pattern
if [[ "$command_output" =~ $expected_pattern ]]; then
    ssh_MaxStartups_message+="SSHD configuration matches 'maxstartups 10:30:60'.\n "
else
    ssh_MaxStartups_message+="SSHD configuration does not match 'maxstartups 10:30:60'.\n "
fi

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*maxstartups\s+(((1[1-9]|[1-9][0-9][0-9]+):([0-9]+):([0-9]+))|(([0-9]+):(3[1-9]|[4-9][0-9]|[1-9][0-9][0-9]+):([0-9]+))|(([0-9]+):([0-9]+):(6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+)))' /etc/ssh/sshd_config)

# Check if command 2 output is empty (no lines matching less restrictive MaxStartups values)
if [ -z "$command2_output" ]; then
    ssh_MaxStartups_message+="No less restrictive 'MaxStartups' values found in /etc/ssh/sshd_config.\n"
else
    ssh_MaxStartups_message+="Found less restrictive 'MaxStartups' values in /etc/ssh/sshd_config.\n"
    ssh_MaxStartups_result="Fail"
fi

# Check overall audit result
if [[ "$command_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_MaxStartups_result="Pass"
else
    ssh_MaxStartups_result="Fail"
fi

# 5.2.18	Ensure SSH MaxSessions is set to 10 or less
# Define variables for audit message and result
ssh_MaxSessions_message=""
ssh_MaxSessions_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep -i maxsessions)

# Define expected pattern for Command 1
expected_pattern="maxsessions 10"

# Check if command output contains expected pattern
if [[ "$command_output" =~ $expected_pattern ]]; then
    ssh_MaxSessions_message+="SSHD configuration matches 'maxsessions 10'.\n "
else
    ssh_MaxSessions_message+="SSHD configuration does not match 'maxsessions 10'. \n"
fi

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*MaxSessions\s+(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)' /etc/ssh/sshd_config)

# Check if command 2 output is empty (no lines matching more than 10 MaxSessions)
if [ -z "$command2_output" ]; then
    ssh_MaxSessions_message+="No 'MaxSessions' values greater than 10 found in /etc/ssh/sshd_config.\n"
else
    ssh_MaxSessions_message+="Found 'MaxSessions' values greater than 10 in /etc/ssh/sshd_config.\n"
    ssh_MaxSessions_result="Fail"
fi

# Check overall audit result
if [[ "$command_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_MaxSessions_result="Pass"
else
    ssh_MaxSessions_result="Fail"
fi

# 5.2.19	Ensure SSH LoginGraceTime is set to one minute or less
# Define variables for audit message and result
ssh_LoginGraceTime_message=""
ssh_LoginGraceTime_result="Fail"

# Command 1: Check sshd configuration using sshd -T
command_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep logingracetime)

# Define expected pattern for Command 1
expected_pattern="logingracetime 60"

# Check if command output contains expected pattern
if [[ "$command_output" =~ $expected_pattern ]]; then
    ssh_LoginGraceTime_message+="SSHD configuration matches 'logingracetime 60'.\n"
else
    ssh_LoginGraceTime_message+="SSHD configuration does not match 'logingracetime 60'.\n"
fi

# Command 2: Check sshd_config file for specific patterns
command2_output=$(grep -Ei '^\s*LoginGraceTime\s+(0|6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+|[^1]m)' /etc/ssh/sshd_config)

# Check if command 2 output is empty (no lines matching less restrictive LoginGraceTime values)
if [ -z "$command2_output" ]; then
    ssh_LoginGraceTime_message+="No less restrictive 'LoginGraceTime' values found in /etc/ssh/sshd_config.\n"
else
    ssh_LoginGraceTime_message+="Found less restrictive 'LoginGraceTime' values in /etc/ssh/sshd_config.\n"
    ssh_LoginGraceTime_result="Fail"
fi

# Check overall audit result
if [[ "$command_output" =~ $expected_pattern ]] && [ -z "$command2_output" ]; then
    ssh_LoginGraceTime_result="Pass"
else
    ssh_LoginGraceTime_result="Fail"
fi

# 5.2.20	Ensure SSH Idle Timeout Interval is configured
# Define variables for audit message and result
ssh_idle_timeout_message=""
ssh_idle_timeout_result="Fail"

# Command 1: Check ClientAliveInterval configuration using sshd -T
clientaliveinterval_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep clientaliveinterval)

# Define expected pattern for ClientAliveInterval
expected_clientaliveinterval="clientaliveinterval 900"

# Check if ClientAliveInterval command output matches expected pattern
if [[ "$clientaliveinterval_output" =~ $expected_clientaliveinterval ]]; then
    ssh_idle_timeout_message+="ClientAliveInterval is set to 900 seconds. \n"
else
    ssh_idle_timeout_message+="ClientAliveInterval is not set to 900 seconds. \n"
fi

# Command 2: Check ClientAliveCountMax configuration using sshd -T
clientalivecountmax_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep clientalivecountmax)

# Define expected pattern for ClientAliveCountMax
expected_clientalivecountmax="clientalivecountmax 3"

# Check if ClientAliveCountMax command output matches expected pattern
if [[ "$clientalivecountmax_output" =~ $expected_clientalivecountmax ]]; then
    ssh_idle_timeout_message+="ClientAliveCountMax is set to 3. \n"
else
    ssh_idle_timeout_message+="ClientAliveCountMax is not set to 3. \n"
fi

# Command 3: Check sshd_config file for ClientAliveInterval configuration
config_clientaliveinterval=$(grep -Ei '^\s*ClientAliveInterval\s+(0|9[0-9][1-9]|[1-9][0-9][0-9][0-9]+|1[6-9]m|[2-9][0-9]m|[1-9][0-9][0-9]+m)\b' /etc/ssh/sshd_config)

# Check if there is no output indicating less restrictive ClientAliveInterval settings
if [ -z "$config_clientaliveinterval" ]; then
    ssh_idle_timeout_message+="No less restrictive 'ClientAliveInterval' values found in /etc/ssh/sshd_config. \n"
else
    ssh_idle_timeout_message+="Found less restrictive 'ClientAliveInterval' values in /etc/ssh/sshd_config. \n"
    ssh_idle_timeout_result="Fail"
fi

# Command 4: Check sshd_config file for ClientAliveCountMax configuration
config_clientalivecountmax=$(grep -Ei '^\s*ClientAliveCountMax\s+([1-9]|[1-9][0-9]+)\b' /etc/ssh/sshd_config)

# Check if there is no output indicating less restrictive ClientAliveCountMax settings
if [ -z "$config_clientalivecountmax" ]; then
    ssh_idle_timeout_message+="No less restrictive 'ClientAliveCountMax' values found in /etc/ssh/sshd_config. \n"
else
    ssh_idle_timeout_message+="Found less restrictive 'ClientAliveCountMax' values in /etc/ssh/sshd_config. \n"
    ssh_idle_timeout_result="Fail"
fi

# Check overall audit result
if [[ "$clientaliveinterval_output" =~ $expected_clientaliveinterval ]] && [[ "$clientalivecountmax_output" =~ $expected_clientalivecountmax ]] && \
   [ -z "$config_clientaliveinterval" ] && [ -z "$config_clientalivecountmax" ]; then
    ssh_idle_timeout_result="Pass"
else
    ssh_idle_timeout_result="Fail"
fi

# 5.3.1	Ensure sudo is installed
# Define variables for audit message and result
sudo_installed_message=""
sudo_installed_result="Fail"

# Run the command and capture output
command_output=$(dnf list sudo)

echo "$command_output"

# Check if sudo is installed
if echo "$command_output" | grep -q '^Installed Packages'; then
    sudo_installed_message+="sudo is installed. \n"
    sudo_installed_message+="Command Output: \n$command_output \n"
    sudo_installed_result="Pass"
else
    sudo_installed_message+="sudo is not installed. \n"
    sudo_installed_result="Fail"
fi

#   5.3.2	Ensure sudo commands use pty
# Define variables for audit message and result
sudo_command_use_pty_message=""
sudo_command_use_pty_result="Fail"

# Check for use_pty setting in sudoers
use_pty_setting=$(grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*)

if [[ -n "$use_pty_setting" ]]; then
    sudo_command_use_pty_message+="use_pty setting found in sudoers file(s): \n$use_pty_setting \n"
    sudo_command_use_pty_result="Pass"
else
    sudo_command_use_pty_message+="use_pty setting not found in sudoers file(s). \n"
    sudo_command_use_pty_result="Fail"
fi

# 5.3.3	Ensure sudo log file exists
# Define variables for audit message and result
sudo_log_file_message=""
sudo_log_file_result="Fail"

# Check for logfile setting in sudoers
logfile_setting=$(grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*)

if [[ -n "$logfile_setting" ]]; then
    sudo_log_file_message+="logfile setting found in sudoers file(s): \n$logfile_setting \n"
    sudo_log_file_result="Pass"
else
    sudo_log_file_message+="logfile setting not found in sudoers file(s). \n"
    sudo_log_file_result="Fail"
fi

# 5.3.5	Ensure re-authentication for privilege escalation is not disabled globally
# Define variables for audit message and result
reauthentication_priv_escalation_message=""
reauthentication_priv_escalation_result="Pass"

# Check for !authenticate tag in sudoers files
authenticate_lines=$(grep -r "^[^#].*!authenticate" /etc/sudoers* 2>/dev/null)

if [[ -n "$authenticate_lines" ]]; then
    reauthentication_priv_escalation_message+="Lines found with !authenticate tag in sudoers files: \n$authenticate_lines \n"
    reauthentication_priv_escalation_result="Fail"
else
    reauthentication_priv_escalation_message+="No lines found with !authenticate tag in sudoers files. \n"
    reauthentication_priv_escalation_result="Pass"
fi

# 5.3.6	Ensure sudo authentication timeout is configured correctly
# Define variables for audit message and result
sudo_auth_timeout_message=""
sudo_auth_timeout_result="Pass"

# Check timestamp_timeout configuration in sudoers files
timeout_value=$(grep -roP "timestamp_timeout=\K[0-9]*" /etc/sudoers* 2>/dev/null)

if [[ -n "$timeout_value" ]]; then
    sudo_auth_timeout_message+="timestamp_timeout value configured: $timeout_value minutes \n"

    # Check if timestamp_timeout exceeds 15 minutes
    if (( timeout_value > 15 )); then
        sudo_auth_timeout_message+="Fail: timestamp_timeout is greater than 15 minutes \n"
        sudo_auth_timeout_result="Fail"
    else
        sudo_auth_timeout_message+="Pass: timestamp_timeout is 15 minutes or less \n"
    fi
else
    sudo_auth_timeout_message+="No timestamp_timeout configured in /etc/sudoers* files \n"
    
    # Check default timestamp_timeout (5 minutes)
    default_timeout=$(sudo -V | grep "Authentication timestamp timeout:")
    sudo_auth_timeout_message+="Default timeout: $default_timeout \n"

    if [[ "$default_timeout" =~ "5.0 minutes" ]]; then
        sudo_auth_timeout_message+="Pass: Default timestamp_timeout is 5 minutes \n"
    else
        sudo_auth_timeout_message+="Fail: Default timestamp_timeout is not 5 minutes \n"
        sudo_auth_timeout_result="Fail"
    fi
fi

# 5.3.7	Ensure access to the su command is restricted
# Define variables
su_command_access_message=""
su_command_access_result="Pass"

# Check PAM configuration for su command
pam_su_config=$(grep -Pi '^\h*auth\h+(?:required|requisite)\h+pam_wheel\.so\h+(?:[^#\n\r]+\h+)?((?!\2)(use_uid\b|group=\H+\b))\h+(?:[^#\n\r]+\h+)?((?!\1)(use_uid\b|group=\H+\b))(\h+.*)?$' /etc/pam.d/su)

if [[ -z "$pam_su_config" ]]; then
    su_command_access_message+="Fail: PAM configuration for su command is not as expected \n"
    su_command_access_result="Fail"
else
    su_command_access_message+="Pass: PAM configuration for su command is as expected \n"
fi

# Check all groups to ensure they contain no users
while IFS=: read -r group_name _ _ user_list; do
    if [[ -n "$user_list" ]]; then
        su_command_access_message+="Fail: Group $group_name contains users: $user_list \n"
        su_command_access_result="Fail"
    else
        su_command_access_message+="Pass: Group $group_name contains no users \n"
    fi
done < /etc/group

# 5.5.1	Ensure password creation requirements are configured
# Define variables
password_creation_requirement_message=""
password_creation_requirement_result="Pass"

# Check for pam_pwquality.so settings in system-auth and password-auth files
pwquality_files=$(grep pam_pwquality.so /etc/pam.d/system-auth /etc/pam.d/password-auth)

if [[ -z "$pwquality_files" ]]; then
    password_creation_requirement_message+="Fail: pam_pwquality.so is not configured properly in system-auth or password-auth \n"
    password_creation_requirement_result="Fail"
else
    password_creation_requirement_message+="Pass: pam_pwquality.so is configured properly in system-auth and password-auth \n"
fi

# Check password length requirement
minlen=$(grep "^minlen" /etc/security/pwquality.conf | awk -F '=' '{print $2}')
if [[ -n "$minlen" && "$minlen" -ge 14 ]]; then
    password_creation_requirement_message+="Pass: Minimum password length is $minlen characters \n"
else
    password_creation_requirement_message+="Fail: Minimum password length is less than 14 characters \n"
    password_creation_requirement_result="Fail"
fi

# Check password complexity requirement
minclass=$(grep "^minclass" /etc/security/pwquality.conf | awk -F '=' '{print $2}')
if [[ -n "$minclass" && "$minclass" -ge 4 ]]; then
    password_creation_requirement_message+="Pass: Minimum password complexity (minclass) is $minclass \n"
else
    password_creation_requirement_message+="Fail: Minimum password complexity (minclass) is less than 4 \n"
    password_creation_requirement_result="Fail"
fi

# 5.5.2	Ensure lockout for failed password attempts is configured
# Variable to store audit messages
lockout_for_failed_password_message=""

# Function to check faillock.conf for versions 8.2 and later
check_faillock_conf_8_2_and_later() {
    # Check deny setting
    deny=$(grep -E '^\s*deny\s*=\s*[1-5]\b' /etc/security/faillock.conf)
    if [[ -z "$deny" ]]; then
        lockout_for_failed_password_message+="FAIL: deny setting in faillock.conf is not configured correctly.\n"
    else
        lockout_for_failed_password_message+="PASS: deny setting in faillock.conf is configured correctly.\n"
    fi
    
    # Check unlock_time setting
    unlock_time=$(grep -E '^\s*unlock_time\s*=\s*(0|9[0-9][0-9]|[1-9][0-9][0-9][0-9]+)\b' /etc/security/faillock.conf)
    if [[ -z "$unlock_time" ]]; then
        lockout_for_failed_password_message+="FAIL: unlock_time setting in faillock.conf is not configured correctly.\n"
    else
        lockout_for_failed_password_message+="PASS: unlock_time setting in faillock.conf is configured correctly.\n"
    fi
}

# Function to check pam_faillock.so module for versions 8.0 and 8.1
check_pam_faillock_so_8_0_and_8_1() {
    # Check password-auth file
    password_auth=$(grep -E '^\s*auth\s+required\s+pam_faillock.so\s+' /etc/pam.d/password-auth)
    if [[ -z "$password_auth" ]]; then
        lockout_for_failed_password_message+="FAIL: pam_faillock.so configuration in password-auth is missing or incorrect.\n"
    else
        lockout_for_failed_password_message+="PASS: pam_faillock.so configuration in password-auth is correct.\n"
    fi
    
    # Check system-auth file
    system_auth=$(grep -E '^\s*auth\s+required\s+pam_faillock.so\s+' /etc/pam.d/system-auth)
    if [[ -z "$system_auth" ]]; then
        lockout_for_failed_password_message+="FAIL: pam_faillock.so configuration in system-auth is missing or incorrect.\n"
    else
        lockout_for_failed_password_message+="PASS: pam_faillock.so configuration in system-auth is correct.\n"
    fi
}

# Perform audit based on version
major_version=$(cat /etc/redhat-release | awk '{print $7}' | cut -d'.' -f1)
if [[ "$major_version" -ge 8 ]]; then
    check_faillock_conf_8_2_and_later
else
    check_pam_faillock_so_8_0_and_8_1
fi

# Determine overall audit result
if [[ "$lockout_for_failed_password_message" =~ "FAIL" ]]; then
    lockout_for_failed_password_result="FAIL"
else
    lockout_for_failed_password_result="PASS"
fi

# 5.5.3	Ensure password reuse is limited
# Initialize audit variables
password_reuse_limit_message=""
password_reuse_limit_result="Pass"

# Run the command to check system-auth configuration
system_auth=$(grep -P '^\h*password\h+(requisite|sufficient)\h+(pam_pwhistory\.so|pam_unix\.so)\h+([^#\n\r]+\h+)?remember=([5-9]|[1-9][0-9]+)\h*(\h+.*)?$' /etc/pam.d/system-auth)

if [[ -n "$system_auth" ]]; then
    password_reuse_limit_message+="Pass: System-auth has remembered password history configured properly \n"
else
    password_reuse_limit_message+="Fail: System-auth does not have remembered password history configured properly \n"
    password_reuse_limit_result="Fail"
fi

# 5.5.4	Ensure password hashing algorithm is SHA-512
# Initialize audit message and result
password_hashing_algorithm_message=""
password_hashing_algorithm_result="Pass"

# Check /etc/libuser.conf for crypt_style = sha512
libuser_conf=$(grep -Ei '^\s*crypt_style\s*=\s*sha512\b' /etc/libuser.conf)
if [[ -z "$libuser_conf" ]]; then
    password_hashing_algorithm_message+="Fail: /etc/libuser.conf does not have crypt_style = sha512 configured\n"
    password_hashing_algorithm_result="Fail"
else
    password_hashing_algorithm_message+="Pass: /etc/libuser.conf has crypt_style = sha512 configured\n"
fi

# Check /etc/login.defs for ENCRYPT_METHOD SHA512
login_defs=$(grep -Ei '^\s*ENCRYPT_METHOD\s+SHA512\b' /etc/login.defs)
if [[ -z "$login_defs" ]]; then
    password_hashing_algorithm_message+="Fail: /etc/login.defs does not have ENCRYPT_METHOD SHA512 configured\n"
    password_hashing_algorithm_result="Fail"
else
    password_hashing_algorithm_message+="Pass: /etc/login.defs has ENCRYPT_METHOD SHA512 configured\n"
fi

# Check /etc/pam.d/system-auth and /etc/pam.d/password-auth for pam_unix.so with sha512
auth_files="/etc/pam.d/system-auth /etc/pam.d/password-auth"
for file in $auth_files; do
    pam_unix_sha512=$(grep -P -- '^\h*password\h+(requisite|required|sufficient)\h+pam_unix\.so(\h+[^#\n\r]+)?\h+sha512\b.*$' "$file")
    if [[ -z "$pam_unix_sha512" ]]; then
        password_hashing_algorithm_message+="Fail: $file does not have pam_unix.so configured with sha512\n"
        password_hashing_algorithm_result="Fail"
    else
        password_hashing_algorithm_message+="Pass: $file has pam_unix.so configured with sha512\n"
    fi
done

# 5.6.2	Ensure system accounts are secured
# Initialize audit message and result
system_account_secure_message=""
system_account_secure_result="Pass"

# Run the first command and check if any results are returned
first_command_result=$(awk -F: '($1 !~ /^(root|halt|sync|shutdown|nfsnobody)$/ && $3 < ' $(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)' && $7 !~ /^(\/usr)?\/sbin\/nologin(\/)?$/ && $7 !~ /(\/usr)?\/bin\/false(\/)?$/) { print $1 }' /etc/passwd)

if [[ -n "$first_command_result" ]]; then
    system_account_secure_message+="Fail: The following users have shells other than /sbin/nologin or /bin/false and have UID less than UID_MIN:\n$first_command_result\n"
    system_account_secure_result="Fail"
else
    system_account_secure_message+="Pass: No users with shells other than /sbin/nologin or /bin/false and with UID less than UID_MIN found.\n"
fi

# Run the second command and check if any results are returned
second_command_result=$(awk -F: '($1 != "root" && $1 !~ /^\+/ && $3 < '$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)') {print $1}' /etc/passwd | xargs -I '{}' passwd -S '{}' | awk '($2 != "L" && $2 != "LK") {print $1}')

if [[ -n "$second_command_result" ]]; then
    system_account_secure_message+="Fail: The following users with UID less than UID_MIN have passwords that are not locked:\n$second_command_result\n"
    system_account_secure_result="Fail"
else
    system_account_secure_message+="Pass: No users with UID less than UID_MIN have passwords that are not locked.\n"
fi

# 5.6.3	Ensure default user shell timeout is 900 seconds or less
# Initialize audit message and result
user_shell_timeout_message=""
user_shell_timeout_result="Pass"

# Variables to store the findings
output1=""
output2=""

# Check the configuration files for TMOUT settings
[ -f /etc/bashrc ] && BRC="/etc/bashrc"
for f in "$BRC" /etc/profile /etc/profile.d/*.sh; do
    if grep -Pq '^\s*([^#]+\s+)?TMOUT=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9])\b' "$f" &&
       grep -Pq '^\s*([^#]+;\s*)?readonly\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f" &&
       grep -Pq '^\s*([^#]+;\s*)?export\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f"; then
        output1="$f"
    fi
done

# Check for any incorrect TMOUT settings
if grep -Pq '^\s*([^#]+\s+)?TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9]\d{3,})\b' /etc/profile /etc/profile.d/*.sh "$BRC"; then
    output2=$(grep -Ps '^\s*([^#]+\s+)?TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9]\d{3,})\b' /etc/profile /etc/profile.d/*.sh $BRC)
fi

# Determine the audit result based on the findings
if [ -n "$output1" ] && [ -z "$output2" ]; then
    user_shell_timeout_message+="Pass: TMOUT is configured properly in: $output1\n"
else
    [ -z "$output1" ] && user_shell_timeout_message+="Fail: TMOUT is not configured\n" && user_shell_timeout_result="Fail"
    [ -n "$output2" ] && user_shell_timeout_message+="Fail: TMOUT is incorrectly configured in: $output2\n" && user_shell_timeout_result="Fail"
fi

# 5.6.4	Ensure default group for the root account is GID 0
# Initialize audit message and result
default_group_for_root_message=""
default_group_for_root_result="Pass"

# Check the root GID
root_gid=$(grep "^root:" /etc/passwd | cut -f4 -d:)

# Evaluate the result
if [ "$root_gid" -eq 0 ]; then
    default_group_for_root_message+="Pass: The root group ID is correctly set to 0.\n"
else
    default_group_for_root_message+="Fail: The root group ID is not set to 0, current GID is $root_gid.\n"
    default_group_for_root_result="Fail"
fi

# 5.6.5	Ensure default user umask is 027 or more restrictive
# Initialize audit message and result
default_user_umask_message=""
default_user_umask_result="Pass"

# Check for default user umask setting
passing=""
if grep -Eiq '^\s*UMASK\s+(0[0-7][2-7]7|[0-7][2-7]7)\b' /etc/login.defs && \
   grep -Eqi '^\s*USERGROUPS_ENAB\s*"no"\b' /etc/login.defs && \
   grep -Eq '^\s*session\s+(optional|requisite|required)\s+pam_umask\.so\b' /etc/pam.d/common-session && \
   grep -REiq '^\s*UMASK\s+\s*(0[0-7][2-7]7|[0-7][2-7]7|u=(r?|w?|x?)(r?|w?|x?)(r?|w?|x?),g=(r?x?|x?r?),o=)\b' /etc/profile* /etc/bashrc*; then
    passing=true
fi

if [ "$passing" = true ]; then
    default_user_umask_message+="Pass: Default user umask is set correctly.\n"
else
    default_user_umask_message+="Fail: Default user umask is not set correctly.\n"
    default_user_umask_result="Fail"
fi

# Check for less restrictive system-wide umask setting
less_restrictive_umask=$(grep -RPi '(^|^[^#]*)\s*umask\s+([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b|[0-7][01][0-7]\b|[0-7][0-7][0-6]\b|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+\b|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?\b)' /etc/login.defs /etc/profile* /etc/bashrc*)

if [ -z "$less_restrictive_umask" ]; then
    default_user_umask_message+="Pass: No less restrictive system-wide umask is set.\n"
else
    default_user_umask_message+="Fail: Less restrictive system-wide umask is set in the following files:\n$less_restrictive_umask\n"
    default_user_umask_result="Fail"
fi

# 5.6.1.1	Ensure password expiration is 365 days or less
# Initialize audit message and result
password_expired_365_message=""
password_expired_365_result="Pass"

# Verify PASS_MAX_DAYS in /etc/login.defs
login_defs_max_days=$(grep -E '^PASS_MAX_DAYS' /etc/login.defs)

if [[ $login_defs_max_days =~ ^PASS_MAX_DAYS[[:space:]]+([0-9]+) ]]; then
    max_days=${BASH_REMATCH[1]}
    if [ "$max_days" -le 365 ]; then
        password_expired_365_message+="Pass: PASS_MAX_DAYS is set to $max_days in /etc/login.defs and conforms to site policy.\n"
    else
        password_expired_365_message+="Fail: PASS_MAX_DAYS is set to $max_days in /etc/login.defs and does not conform to site policy.\n"
        password_expired_365_result="Fail"
    fi
else
    password_expired_365_message+="Fail: PASS_MAX_DAYS is not set in /etc/login.defs.\n"
    password_expired_365_result="Fail"
fi

# Verify PASS_MAX_DAYS for all users in /etc/shadow
users_exceeding_max_days=$(grep -E '^[^:]+:[^!*]' /etc/shadow | cut -d: -f1,5 | awk -F: '$2 > 365 {print $1 ":" $2}')

if [ -z "$users_exceeding_max_days" ]; then
    password_expired_365_message+="Pass: All users' PASS_MAX_DAYS in /etc/shadow conform to site policy.\n"
else
    password_expired_365_message+="Fail: The following users have PASS_MAX_DAYS greater than 365 in /etc/shadow:\n$users_exceeding_max_days\n"
    password_expired_365_result="Fail"
fi

# 5.6.1.2	Ensure minimum days between password changes is 7 or more
# Initialize audit message and result
minimum_day_pass_change_message=""
minimum_day_pass_change_result="Pass"

# Verify PASS_MIN_DAYS in /etc/login.defs
login_defs_min_days=$(grep -E '^\s*PASS_MIN_DAYS' /etc/login.defs)

if [[ $login_defs_min_days =~ ^\s*PASS_MIN_DAYS[[:space:]]+([0-9]+) ]]; then
    min_days=${BASH_REMATCH[1]}
    if [ "$min_days" -ge 7 ]; then
        minimum_day_pass_change_message+="Pass: PASS_MIN_DAYS is set to $min_days in /etc/login.defs and conforms to site policy.\n"
    else
        minimum_day_pass_change_message+="Fail: PASS_MIN_DAYS is set to $min_days in /etc/login.defs and does not conform to site policy.\n"
        minimum_day_pass_change_result="Fail"
    fi
else
    minimum_day_pass_change_message+="Fail: PASS_MIN_DAYS is not set in /etc/login.defs.\n"
    minimum_day_pass_change_result="Fail"
fi

# Verify PASS_MIN_DAYS for all users in /etc/shadow
users_below_min_days=$(grep -E '^[^:]+:[^!*]' /etc/shadow | cut -d: -f1,4 | awk -F: '$2 < 7 {print $1 ":" $2}')

if [ -z "$users_below_min_days" ]; then
    minimum_day_pass_change_message+="Pass: All users' PASS_MIN_DAYS in /etc/shadow conform to site policy.\n"
else
    minimum_day_pass_change_message+="Fail: The following users have PASS_MIN_DAYS less than 7 in /etc/shadow:\n$users_below_min_days\n"
    minimum_day_pass_change_result="Fail"
fi

# 5.6.1.3	Ensure password expiration warning days is 7 or more
# Initialize audit message and result
pass_expired_warn_date_message=""
pass_expired_warn_date_result="Pass"

# Verify PASS_WARN_AGE in /etc/login.defs
login_defs_warn_age=$(grep -E '^\s*PASS_WARN_AGE' /etc/login.defs)

if [[ $login_defs_warn_age =~ ^\s*PASS_WARN_AGE[[:space:]]+([0-9]+) ]]; then
    warn_age=${BASH_REMATCH[1]}
    if [ "$warn_age" -ge 7 ]; then
        pass_expired_warn_date_message+="Pass: PASS_WARN_AGE is set to $warn_age in /etc/login.defs and conforms to site policy.\n"
    else
        pass_expired_warn_date_message+="Fail: PASS_WARN_AGE is set to $warn_age in /etc/login.defs and does not conform to site policy.\n"
        pass_expired_warn_date_result="Fail"
    fi
else
    pass_expired_warn_date_message+="Fail: PASS_WARN_AGE is not set in /etc/login.defs.\n"
    pass_expired_warn_date_result="Fail"
fi

# Verify PASS_WARN_AGE for all users in /etc/shadow
users_below_warn_age=$(grep -E '^[^:]+:[^!*]' /etc/shadow | cut -d: -f1,6 | awk -F: '$2 < 7 {print $1 ":" $2}')

if [ -z "$users_below_warn_age" ]; then
    pass_expired_warn_date_message+="Pass: All users' PASS_WARN_AGE in /etc/shadow conform to site policy.\n"
else
    pass_expired_warn_date_message+="Fail: The following users have PASS_WARN_AGE less than 7 in /etc/shadow:\n$users_below_warn_age\n"
    pass_expired_warn_date_result="Fail"
fi

# 5.6.1.4	Ensure inactive password lock is 30 days or less
# Initialize audit message and result
inactive_pass_lock_message=""
inactive_pass_lock_result="Pass"

# Verify INACTIVE in useradd default settings
useradd_inactive=$(useradd -D | grep -E '^\s*INACTIVE\s*=\s*([0-9]+)')

if [[ $useradd_inactive =~ ^\s*INACTIVE\s*=\s*([0-9]+) ]]; then
    inactive=${BASH_REMATCH[1]}
    if [ "$inactive" -le 30 ]; then
        inactive_pass_lock_message+="Pass: INACTIVE is set to $inactive days in useradd default settings and conforms to site policy.\n"
    else
        inactive_pass_lock_message+="Fail: INACTIVE is set to $inactive days in useradd default settings and does not conform to site policy.\n"
        inactive_pass_lock_result="Fail"
    fi
else
    inactive_pass_lock_message+="Fail: INACTIVE is not set in useradd default settings.\n"
    inactive_pass_lock_result="Fail"
fi

# Verify INACTIVE for all users in /etc/shadow
inactive_users=$(awk -F: '/^[^#:]+:[^\!\*:]*:[^:]*:[^:]*:[^:]*:[^:]*:(\s*|-1|3[1-9]|[4-9][0-9]|[1-9][0-9][0-9]+):[^:]*:[^:]*\s*$/' /etc/shadow | cut -d: -f1,7)

if [ -z "$inactive_users" ]; then
    inactive_pass_lock_message+="Pass: All users' INACTIVE settings in /etc/shadow conform to site policy.\n"
else
    inactive_pass_lock_message+="Fail: The following users have INACTIVE settings more than 30 days in /etc/shadow:\n$inactive_users\n"
    inactive_pass_lock_result="Fail"
fi

# 5.6.1.5	Ensure all users last password change date is in the past
# Initialize audit message and result
user_last_pass_change_message=""
user_last_pass_change_result="Pass"

# Verify last password change date for all users in /etc/shadow
users_with_future_password_change=$(awk -F: '/^[^:]+:[^!*]/{print $1}' /etc/shadow | while read -r usr; do
    change=$(date -d "$(chage --list $usr | grep '^Last password change' | cut -d: -f2 | grep -v 'never$')" +%s 2>/dev/null)
    if [[ $? -eq 0 && "$change" -gt "$(date +%s)" ]]; then
        echo "User: \"$usr\" last password change was \"$(chage --list $usr | grep '^Last password change' | cut -d: -f2)\""
    fi
done)

# Check if any users have a future password change date
if [ -z "$users_with_future_password_change" ]; then
    user_last_pass_change_message+="Pass: No users have a last password change date in the future.\n"
else
    user_last_pass_change_message+="Fail: The following users have a last password change date in the future:\n$users_with_future_password_change\n"
    user_last_pass_change_result="Fail"
fi

# 6.1.2	Ensure sticky bit is set on all world-writable directories
# Initialize audit message and result
sticky_bit_world_writable_directory_message=""
sticky_bit_world_writable_directory_result="Pass"

# Verify no world writable directories exist without the sticky bit set
world_writable_dirs=$(df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null)

# Check if any directories were found
if [ -z "$world_writable_dirs" ]; then
    sticky_bit_world_writable_directory_message+="Pass: No world writable directories exist without the sticky bit set.\n"
else
    sticky_bit_world_writable_directory_message+="Fail: The following world writable directories do not have the sticky bit set:\n$world_writable_dirs\n"
    sticky_bit_world_writable_directory_result="Fail"
fi

# 6.1.3	Ensure permissions on /etc/passwd are configured
# Variables for audit message and result
permission_etc_passwd_message=""
permission_etc_passwd_result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/passwd)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_passwd_message="PASS: The file attributes match the reference format."
    permission_etc_passwd_result="PASS"
else
    permission_etc_passwd_message="FAIL: The file attributes do not match the reference format."
    permission_etc_passwd_result="FAIL"
fi

# 6.1.4	Ensure permissions on /etc/shadow are configured
# Variables for audit message and result
permission_etc_shadow_message=""
permission_etc_shadow_result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/shadow)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0000/----------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_shadow_message="PASS: The file attributes match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_shadow_result="PASS"
else
    permission_etc_shadow_message="FAIL: The file attributes do not match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_shadow_result="FAIL"
fi

# 6.1.5	Ensure permissions on /etc/group are configured
# Variables for audit message and result
permission_etc_group_message=""
permission_etc_group_result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/group)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_group_message="PASS: The file attributes match the reference format 'Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_group_result="PASS"
else
    permission_etc_group_message="FAIL: The file attributes do not match the reference format 'Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_group_result="FAIL"
fi

# 6.1.6	Ensure permissions on /etc/gshadow are configured
# Variables for audit message and result
permission_etc_gshadow_message=""
permission_etc_gshadow_result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/gshadow)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0000/----------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_gshadow_message="PASS: The file attributes match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_gshadow_result="PASS"
else
    permission_etc_gshadow_message="FAIL: The file attributes do not match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_gshadow_result="FAIL"
fi

# 6.1.7	Ensure permissions on /etc/passwd- are configured
# Variables for audit message and result
permission_etc_passwd__message=""
permission_etc_passwd__result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/passwd-)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_passwd__message="PASS: The file attributes match the reference format 'Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_passwd__result="PASS"
else
    permission_etc_passwd__message="FAIL: The file attributes do not match the reference format 'Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_passwd__result="FAIL"
fi

# 6.1.8	Ensure permissions on /etc/shadow- are configured
# Variables for audit message and result
permission_etc_shadow__message=""
permission_etc_shadow__result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/shadow-)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0000/----------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_shadow__message="PASS: The file attributes match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_shadow__result="PASS"
else
    permission_etc_shadow__message="FAIL: The file attributes do not match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_shadow__result="FAIL"
fi

# 6.1.9	Ensure permissions on /etc/group- are configured
# Variables for audit message and result
permission_etc_group__message=""
permission_etc_group__result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/group-)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_group__message="PASS: The file attributes match the reference format 'Access: (0644/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_group__result="PASS"
else
    permission_etc_group__message="FAIL: The file attributes do not match the reference format 'Access: (0644/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_group__result="FAIL"
fi

# 6.1.10	Ensure permissions on /etc/gshadow- are configured
# Variables for audit message and result
permission_etc_gshadow__message=""
permission_etc_gshadow__result=""

# Run the stat command and capture output
STAT_OUTPUT=$(stat /etc/gshadow-)

# Extract the line containing Access, Uid, and Gid from the stat output
TARGET_LINE=$(echo "$STAT_OUTPUT" | grep "Access: (")

# Define the reference format
REFERENCE="Access: (0000/----------)  Uid: (    0/    root)   Gid: (    0/    root)"

# Compare the constructed output with the reference format
if [[ "$TARGET_LINE" == "$REFERENCE" ]]; then
    permission_etc_gshadow__message="PASS: The file attributes match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_gshadow__result="PASS"
else
    permission_etc_gshadow__message="FAIL: The file attributes do not match the reference format 'Access: (0000/----------) Uid: ( 0/ root) Gid: ( 0/ root)'."
    permission_etc_gshadow__result="FAIL"
fi

# 6.1.11	Ensure no world writable files exist
# Variables for audit message, result, and world-writable files
no_world_writable_exist_message=""
no_world_writable_exist_result=""
world_writable_files=""

# Function to check world-writable files in a given directory
check_world_writable() {
    local directory=$1
    local files

    # Find world-writable files in the specified directory
    files=$(find "$directory" -xdev -type f -perm -0002 2>/dev/null)

    # Append files to the world_writable_files variable
    if [[ -n "$files" ]]; then
        world_writable_files+="$files"$'\n'
        return 1
    else
        return 0
    fi
}

# Check local filesystems
local_filesystems=$(df --local -P | awk '{if (NR!=1) print $6}')

# Flag to determine if any world-writable files are found
found_world_writable=0

# Iterate over local filesystems
for fs in $local_filesystems; do
    if ! check_world_writable "$fs"; then
        found_world_writable=1
    fi
done

# Generate the audit message
if [[ $found_world_writable -eq 1 ]]; then
    no_world_writable_exist_message="FAIL: World-writable files found on local filesystems:\n$world_writable_files"
    no_world_writable_exist_result="FAIL"
else
    no_world_writable_exist_message="PASS: No world-writable files found on local filesystems."
    no_world_writable_exist_result="PASS"
fi

# 6.1.12	Ensure no unowned files or directories exist
# Variables for audit message, result, and files with no valid owner
no_unowned_file_directory_message=""
no_unowned_file_directory_result=""
no_user_files=""

# Function to check files with no valid owner in a given directory
check_no_user_files() {
    local directory=$1
    local files

    # Find files with no valid owner in the specified directory
    files=$(find "$directory" -xdev -nouser 2>/dev/null)

    # Append files to the no_user_files variable
    if [[ -n "$files" ]]; then
        no_user_files+="$files"$'\n'
        return 1
    else
        return 0
    fi
}

# Check local filesystems
local_filesystems=$(df --local -P | awk '{if (NR!=1) print $6}')

# Flag to determine if any files with no valid owner are found
found_no_user_files=0

# Iterate over local filesystems
for fs in $local_filesystems; do
    if ! check_no_user_files "$fs"; then
        found_no_user_files=1
    fi
done

# Generate the audit message
if [[ $found_no_user_files -eq 1 ]]; then
    no_unowned_file_directory_message="FAIL: Files with no valid owner found on local filesystems:\n$no_user_files"
    no_unowned_file_directory_result="FAIL"
else
    no_unowned_file_directory_message="PASS: No files with no valid owner found on local filesystems."
    no_unowned_file_directory_result="PASS"
fi


# 6.1.13	Ensure no ungrouped files or directories exist
# Variables for audit message, result, and files with no valid group
no_ungrouped_file_directory_message=""
no_ungrouped_file_directory_result=""
no_group_files=""

# Function to check files with no valid group in a given directory
check_no_group_files() {
    local directory=$1
    local files

    # Find files with no valid group in the specified directory
    files=$(find "$directory" -xdev -nogroup 2>/dev/null)

    # Append files to the no_group_files variable
    if [[ -n "$files" ]]; then
        no_group_files+="$files"$'\n'
        return 1
    else
        return 0
    fi
}

# Check local filesystems
local_filesystems=$(df --local -P | awk '{if (NR!=1) print $6}')

# Flag to determine if any files with no valid group are found
found_no_group_files=0

# Iterate over local filesystems
for fs in $local_filesystems; do
    if ! check_no_group_files "$fs"; then
        found_no_group_files=1
    fi
done

# Generate the audit message
if [[ $found_no_group_files -eq 1 ]]; then
    no_ungrouped_file_directory_message="FAIL: Files with no valid group found on local filesystems:\n$no_group_files"
    no_ungrouped_file_directory_result="FAIL"
else
    no_ungrouped_file_directory_message="PASS: No files with no valid group found on local filesystems."
    no_ungrouped_file_directory_result="PASS"
fi

# 6.2.1	Ensure password fields are not empty
# Variables for audit message, result, and users without passwords
password_field_empty_message=""
password_field_empty_result=""
users_without_passwords=""

# Check /etc/shadow for users with empty password fields
users_without_passwords=$(awk -F: '($2 == "") { print $1 " does not have a password "}' /etc/shadow)

# Generate the audit message
if [[ -n "$users_without_passwords" ]]; then
    password_field_empty_message="FAIL: The following users do not have a password:\n$users_without_passwords"
    password_field_empty_result="FAIL"
else
    password_field_empty_message="PASS: All users have passwords set."
    password_field_empty_result="PASS"
fi

# 6.2.2	Ensure all groups in /etc/passwd exist in /etc/group
# Variables for audit message, result, and missing groups
group_passwd_exist_group_message=""
group_passwd_exist_group_result=""
missing_groups=""

# Loop through each unique group ID in /etc/passwd
for group_id in $(cut -s -d: -f4 /etc/passwd | sort -u); do
    # Check if the group ID exists in /etc/group
    if ! grep -q -P "^.*?:[^:]*:$group_id:" /etc/group; then
        # Append missing group information to the missing_groups variable
        missing_groups+="Group $group_id is referenced by /etc/passwd but does not exist in /etc/group"$'\n'
    fi
done

# Generate the audit message
if [[ -n "$missing_groups" ]]; then
    group_passwd_exist_group_message="FAIL: The following groups are referenced by /etc/passwd but do not exist in /etc/group:\n$missing_groups"
    group_passwd_exist_group_result="FAIL"
else
    group_passwd_exist_group_message="PASS: All groups referenced in /etc/passwd exist in /etc/group."
    group_passwd_exist_group_result="PASS"
fi

# 6.2.3	Ensure no duplicate UIDs exist
# Variables for audit message, result, and duplicate UIDs
duplicate_uid_exist_message=""
duplicate_uid_exist_result=""
duplicate_uids=""

# Check for duplicate UIDs
cut -f3 -d":" /etc/passwd | sort -n | uniq -c | while read count uid; do
    if [ "$count" -gt 1 ]; then
        users=$(awk -F: -v uid="$uid" '($3 == uid) { print $1 }' /etc/passwd | xargs)
        duplicate_uids+="Duplicate UID ($uid): $users"$'\n'
    fi
done

# Generate the audit message
if [[ -n "$duplicate_uids" ]]; then
    duplicate_uid_exist_message="FAIL: The following duplicate UIDs were found:\n$duplicate_uids"
    duplicate_uid_exist_result="FAIL"
else
    duplicate_uid_exist_message="PASS: No duplicate UIDs found in /etc/passwd."
    duplicate_uid_exist_result="PASS"
fi

# 6.2.4	Ensure no duplicate GIDs exist
# Variables for audit message, result, and duplicate GIDs
duplicate_gid_exist_message=""
duplicate_gid_exist_result=""
duplicate_gids=""

# Check for duplicate GIDs in /etc/group
cut -d: -f3 /etc/group | sort | uniq -d | while read gid; do
    duplicate_gids+="Duplicate GID ($gid) in /etc/group"$'\n'
done

# Generate the audit message
if [[ -n "$duplicate_gids" ]]; then
    duplicate_gid_exist_message="FAIL: The following duplicate GIDs were found:\n$duplicate_gids"
    duplicate_gid_exist_result="FAIL"
else
    duplicate_gid_exist_message="PASS: No duplicate GIDs found in /etc/group."
    duplicate_gid_exist_result="PASS"
fi

# 6.2.5	Ensure no duplicate user names exist
# Variables for audit message, result, and duplicate login names
duplicate_username_exist_message=""
duplicate_username_exist_result=""
duplicate_logins=""

# Check for duplicate login names in /etc/passwd
cut -d: -f1 /etc/passwd | sort | uniq -d | while read login; do
    duplicate_logins+="Duplicate login name ${login} in /etc/passwd"$'\n'
done

# Generate the audit message
if [[ -n "$duplicate_logins" ]]; then
    duplicate_username_exist_message="FAIL: The following duplicate login names were found:\n$duplicate_logins"
    duplicate_username_exist_result="FAIL"
else
    duplicate_username_exist_message="PASS: No duplicate login names found in /etc/passwd."
    duplicate_username_exist_result="PASS"
fi

# 6.2.6	Ensure no duplicate group names exist
# Variables for audit message, result, and duplicate group names
duplicate_groupname_exist_message=""
duplicate_groupname_exist_result=""
duplicate_groups=""

# Check for duplicate group names in /etc/group
cut -d: -f1 /etc/group | sort | uniq -d | while read -r group; do
    duplicate_groups+="Duplicate group name ${group} in /etc/group"$'\n'
done

# Generate the audit message
if [[ -n "$duplicate_groups" ]]; then
    duplicate_groupname_exist_message="FAIL: The following duplicate group names were found:\n$duplicate_groups"
    duplicate_groupname_exist_result="FAIL"
else
    duplicate_groupname_exist_message="PASS: No duplicate group names found in /etc/group."
    duplicate_groupname_exist_result="PASS"
fi

# 6.2.7	Ensure root PATH Integrity
# Variables for audit message, result, and issues found
root_path_integrity_message=""
root_path_integrity_result="PASS"
issues_found=""

# Get root's PATH environment variable
RPCV=$(sudo -Hiu root env | grep '^PATH=' | cut -d= -f2)

# Check for empty directory (::) in PATH
echo "$RPCV" | grep -q "::" && issues_found+="root's PATH contains an empty directory (::)$'\n'"

# Check for trailing colon (:) in PATH
echo "$RPCV" | grep -q ":$" && issues_found+="root's PATH contains a trailing (:)$'\n'"

# Check each directory in PATH
for dir in $(echo "$RPCV" | tr ":" " "); do
    if [ -d "$dir" ]; then
        dir_info=$(ls -ldH "$dir")
        # Check for current working directory (.)
        echo "$dir_info" | awk '$9 == "." {print "PATH contains current working directory (.)"}'
        # Check ownership and permissions
        if echo "$dir_info" | awk '$3 != "root" {print $9, "is not owned by root"}'; then
            issues_found+="$dir is not owned by root"$'\n'
            root_path_integrity_result="FAIL"
        fi
        if echo "$dir_info" | awk 'substr($1,6,1) != "-" {print $9, "is group writable"}'; then
            issues_found+="$dir is group writable"$'\n'
            root_path_integrity_result="FAIL"
        fi
        if echo "$dir_info" | awk 'substr($1,9,1) != "-" {print $9, "is world writable"}'; then
            issues_found+="$dir is world writable"$'\n'
            root_path_integrity_result="FAIL"
        fi
    else
        issues_found+="$dir is not a directory"$'\n'
        root_path_integrity_result="FAIL"
    fi
done

# Generate the audit message
if [[ -n "$issues_found" ]]; then
    root_path_integrity_message="FAIL: The following issues were found in root's PATH:\n$issues_found"
else
    root_path_integrity_message="PASS: No issues found in root's PATH."
fi

# 6.2.8	Ensure root is the only UID 0 account
# Variables for audit message, result, and users with UID 0
root_uid_0_message=""
root_uid_0_result="PASS"
users_with_uid_0=""

# Run the awk command to get users with UID 0
users_with_uid_0=$(awk -F: '($3 == 0) { print $1 }' /etc/passwd)

# Check if the result contains only "root"
if [[ "$users_with_uid_0" == "root" ]]; then
    root_uid_0_message="PASS: Only 'root' has UID 0."
else
    root_uid_0_message="FAIL: The following users have UID 0, which is not allowed:\n$users_with_uid_0"
    root_uid_0_result="FAIL"
fi

# 6.2.9	Ensure all users' home directories exist
# Variables for audit message, result, and issues found
users_home_directory_message=""
users_home_directory_result="PASS"
issues_found=""

# Run the awk command to get users with interactive shells (excluding specific users) and their home directories
awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 "|" $6 }' /etc/passwd | while IFS='|' read -r user dir; do
    if [ ! -d "$dir" ]; then
        issues_found+="User: \"$user\" home directory: \"$dir\" does not exist.$'\n'"
        users_home_directory_result="FAIL"
    fi
done

# Generate the audit message
if [[ -n "$issues_found" ]]; then
    users_home_directory_message="FAIL: The following user home directories do not exist:\n$issues_found"
else
    users_home_directory_message="PASS: All user home directories exist."
fi

# 6.2.10	Ensure users own their home directories
# Variables for audit message and result
users_own_home_directory_message=""
users_own_home_directory_result="PASS"
output=""
output2=""

# Function to perform the audit
UHOC() {
    # Iterate over users with interactive shells and their home directories
    for i in $(awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) {print $1 ":" $6}' /etc/passwd); do
        user=$(echo "$i" | cut -d: -f1)
        dir=$(echo "$i" | cut -d: -f2)

        # Check if the home directory exists
        if [ ! -d "$dir" ]; then
            [ -z "$output2" ] && output2="The following users' home directories don't exist: \"$user\"" || output2="$output2, \"$user\""
            users_own_home_directory_result="FAIL"
        else
            # Check if the home directory is owned by the user or root
            owner=$(stat -L -c "%U" "$dir")
            if [ "$owner" != "$user" ] && [ "$owner" != "root" ]; then
                [ -z "$output" ] && output="The following users don't own their home directory: \"$user\" home directory is owned by \"$owner\"" || output="$output, \"$user\" home directory is owned by \"$owner\""
                users_own_home_directory_result="FAIL"
            fi
        fi
    done
}

# Call the function
UHOC

# Generate the audit message
if [[ -n "$output" || -n "$output2" ]]; then
    users_own_home_directory_message="FAIL:\n$output\n$output2"
else
    users_own_home_directory_message="PASS: All user home directories exist and are correctly owned."
fi

# 6.2.11	Ensure users' home directories permissions are 750 or more restrictive
# Variables for audit message and result
users__home_directory_permission_message=""
users_home_directory_permission_result="PASS"
output=""

# Run the audit
for i in $(awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) {print $1 ":" $6}' /etc/passwd); do
    user=$(echo "$i" | cut -d: -f1)
    dir=$(echo "$i" | cut -d: -f2)

    # Check if the home directory exists
    if [ ! -d "$dir" ]; then
        output+="User: \"$user\" home directory: \"$dir\" doesn't exist\n"
        users_home_directory_permission_result="FAIL"
    else
        # Check the permissions of the directory
        dirperm=$(stat -L -c "%A" "$dir")
        # Check if the directory permissions are not secure
        if [ "$(echo "$dirperm" | cut -c6)" != "-" ] || [ "$(echo "$dirperm" | cut -c8)" != "-" ] || [ "$(echo "$dirperm" | cut -c9)" != "-" ] || [ "$(echo "$dirperm" | cut -c10)" != "-" ]; then
            output+="User: \"$user\" home directory: \"$dir\" has permissions: $(stat -L -c "%a" "$dir")\n"
            users_home_directory_permission_result="FAIL"
        fi
    fi
done

# Generate the audit message
if [ "$users_home_directory_permission_result" == "PASS" ]; then
    users__home_directory_permission_message="PASS: All user home directories exist and have secure permissions."
else
    users__home_directory_permission_message="FAIL:\n$output"
fi

# 6.2.12	Ensure users' dot files are not group or world writable
# Variables for audit message and result
users_dotFile_not_grp_world_writable_message=""
users_dotFile_not_grp_world_writable_result="PASS"
output=""

# Run the audit
awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 ":" $6 }' /etc/passwd | while read -r user dir; do
    if [ -d "$dir" ]; then
        for file in "$dir"/.*; do
            # Check if the file is not a symbolic link and is a regular file
            if [ ! -h "$file" ] && [ -f "$file" ]; then
                fileperm=$(stat -L -c "%A" "$file")
                # Check if the file permissions are group or world-writable
                if [ "$(echo "$fileperm" | cut -c6)" != "-" ] || [ "$(echo "$fileperm" | cut -c9)" != "-" ]; then
                    output+="User: \"$user\" file: \"$file\" has permissions: \"$fileperm\"\n"
                    users_dotFile_not_grp_world_writable_result="FAIL"
                fi
            fi
        done
    fi
done

# Generate the audit message
if [ "$users_dotFile_not_grp_world_writable_result" == "PASS" ]; then
    users_dotFile_not_grp_world_writable_message="PASS: All files in user home directories have secure permissions."
else
    users_dotFile_not_grp_world_writable_message="FAIL:\n$output"
fi

# 6.2.13	Ensure users' .netrc Files are not group or world accessible
# Variables for audit messages and results
users_netrc_group_accessible_message=""
users_netrc_group_accessible_result="PASS"

# Function to check .netrc files
check_netrc_files() {
    awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 ":" $6 }' /etc/passwd | while read -r user dir; do
        if [ -d "$dir" ]; then
            file="$dir/.netrc"
            if [ ! -h "$file" ] && [ -f "$file" ]; then
                perms=$(stat -L -c "%a" "$file")
                if [ "$perms" -lt 600 ]; then
                    users_netrc_group_accessible_message+="FAILED: User: \"$user\" file: \"$file\" exists with permissions: \"$perms\", remove file or excessive permissions\n"
                    users_netrc_group_accessible_result="FAIL"
                else
                    users_netrc_group_accessible_message+="WARNING: User: \"$user\" file: \"$file\" exists with permissions: \"$perms\", remove file unless required\n"
                fi
            fi
        fi
    done
}

# Run the function
check_netrc_files

# 6.2.14	Ensure no users have .forward files
# Variables for audit messages and results
users_forward_files_message=""
users_forward_files_result="PASS"

# Function to check .forward files
check_forward_files() {
    awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 ":" $6 }' /etc/passwd | while read -r user dir; do
        if [ -d "$dir" ]; then
            file="$dir/.forward"
            if [ ! -h "$file" ] && [ -f "$file" ]; then
                users_forward_files_message+="User: \"$user\" file: \"$file\" exists\n"
                users_forward_files_result="FAIL"
            fi
        fi
    done
}

# Run the function
check_forward_files

# 6.2.15	Ensure no users have .netrc files
# Variables for audit messages and results
users_have_netrc_files_message=""
users_have_netrc_files_result="PASS"

# Function to check .netrc files
check_netrc_files() {
    awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 ":" $6 }' /etc/passwd | while read -r user dir; do
        if [ -d "$dir" ]; then
            file="$dir/.netrc"
            if [ ! -h "$file" ] && [ -f "$file" ]; then
                users_have_netrc_files_message+="User: \"$user\" file: \"$file\" exists\n"
                users_have_netrc_files_result="FAIL"
            fi
        fi
    done
}

# Run the function
check_netrc_files

# 6.2.16	Ensure no users have .rhosts files
# Variables for audit messages and results
no_users_have_rhosts_message=""
no_users_have_rhosts_result="PASS"

# Function to check .rhosts files
check_rhosts_files() {
    awk -F: '($1!~/(halt|sync|shutdown|nfsnobody)/ && $7!~/^(\/usr)?\/sbin\/nologin(\/)?$/ && $7!~/(\/usr)?\/bin\/false(\/)?$/) { print $1 ":" $6 }' /etc/passwd | while read -r user dir; do
        if [ -d "$dir" ]; then
            file="$dir/.rhosts"
            if [ ! -h "$file" ] && [ -f "$file" ]; then
                no_users_have_rhosts_message+="User: \"$user\" file: \"$file\" exists\n"
                no_users_have_rhosts_result="FAIL"
            fi
        fi
    done
}

# Run the function
check_rhosts_files


# Echo the results
function result 
{
	echo "1.10 Ensure system-wide crypto policy is not legacy: $crypto_policy_check_result"
	echo "1.1.1.1 Ensure mounting of cramfs filesystems is disabled: $cramfs_check_result"
	echo "1.1.2.1 Ensure /tmp is a separate partition: $tmp_separated_partition_result"
	echo "1.1.2.2 Ensure nodev option set on /tmp partition: $tmp_partition_nodev_result"
	echo "1.1.2.3 Ensure noexec option set on /tmp partition: $tmp_partition_noexec_result"
	echo "1.1.2.4 Ensure nosuid option set on /tmp partition: $tmp_partition_nosuid_result"
	echo "1.1.3.2 Ensure nodev option set on /var partition: $var_nodev_result"
	echo "1.1.3.3 Ensure noexec option set on /var partition: $var_noexec_result"
	echo "1.1.3.4 Ensure nosuid option set on /var partition: $var_nosuid_result"
	echo "1.1.4.2 Ensure noexec option set on /var/tmp partition: $var_tmp_noexec_result"
	echo "1.1.4.3 Ensure nosuid option set on /var/tmp partition: $var_tmp_nosuid_result"
	echo "1.1.4.4 Ensure nodev option set on /var/tmp partition: $var_tmp_nodev_result"
	echo "1.1.5.2 Ensure nodev option set on /var/log partition: $var_log_nodev_result"
	echo "1.1.5.3 Ensure noexec option set on /var/log partition: $var_log_noexec_result"
	echo "1.1.5.4 Ensure nosuid option set on /var/log partition: $var_log_nosuid_result"
	echo "1.1.6.2 Ensure noexec option set on /var/log/audit partition: $var_log_audit_noexec_result"
	echo "1.1.6.3 Ensure nodev option set on /var/log/audit partition: $var_log_audit_nodev_result"
	echo "1.1.6.4 Ensure nosuid option set on /var/log/audit partition: $var_log_audit_nosuid_result"
	echo "1.1.7.2 Ensure nodev option set on /home partition: $home_nodev_result"
	echo "1.1.7.3 Ensure nosuid option set on /home partition: $home_nosuid_result"
	echo "1.1.7.4 Ensure usrquota option set on /home partition: $home_usrquota_result"
	echo "1.1.7.5 Ensure grpquota option set on /home partition: $home_grpquota_result"
	echo "1.1.8.1 Ensure nodev option set on /dev/shm partition: $dev_shm_nodev_result"
	echo "1.1.8.2 Ensure noexec option set on /dev/shm partition: $dev_shm_noexec_result"
	echo "1.1.8.3 Ensure nosuid option set on /dev/shm partition: $dev_shm_nosuid_result"
	echo "1.2.2 Ensure gpgcheck is globally activated: $gpgcheck_result"
	echo "1.3.1 Ensure AIDE is installed: $aide_result"
	echo "1.3.2 Ensure filesystem integrity is regularly checked: $filesystem_integrity_result"
	echo "1.4.1 Ensure bootloader password is set: $bootloader_passwd_set"
	echo "1.4.2 Ensure permissions on bootloader config are configured: $bootloader_permission_config_result"
	echo "1.5.1 Ensure core dump storage is disabled: $core_dump_storage_result"
	echo "1.5.2 Ensure core dump backtraces are disabled: $core_dump_backtraces_result"
	echo "1.5.3 Ensure address space layout randomization (ASLR) is enabled: $aslr_result"
	echo "1.6.1.1 Ensure SELinux is installed: $SELinux_rpm_result"
	echo "1.6.1.2 Ensure SELinux is not disabled in bootloader configuration: $SElinux_not_disabled_bootloader_config_result"
	echo "1.6.1.4 Ensure the SELinux mode is not disabled: $seLinux_configured_result"
	echo "1.6.1.6 Ensure no unconfined services exist: $no_confined_services_result"
	echo "1.6.1.8 Ensure the MCS Translation Service (mcstrans) is not installed: $mcstrans_result"
	echo "1.7.1 Ensure message of the day is configured properly: $motd_result"
	echo "1.7.2 Ensure local login warning banner is configured properly: $issue_content_result"
	echo "1.7.3 Ensure remote login warning banner is configured properly: $remote_login_warning_result"
	echo "1.7.4 Ensure permissions on /etc/motd are configured: $etc_motd_result"
	echo "1.7.5 Ensure permissions on /etc/issue are configured: $etc_issue_result"
	echo "1.7.6 Ensure permissions on /etc/issue.net are configured: $etc_issueNet_result"
	echo "1.8.2 Ensure GDM login banner is configured: $gdm_overall_result"
	echo "1.8.3 Ensure last logged in user display is disabled: $last_login_result"
	echo "1.8.4 Ensure XDMCP is not enabled: $xdmcp_result"
	echo "2.1.1 Ensure time synchronization is in use: $chrony_installed_result"
	echo "2.1.2 Ensure chrony is configured: $chrony_config_result"
	echo "2.2.1 Ensure xinetd is not installed: $xinetd_result"
	echo "2.2.5 Ensure DHCP Server is not installed: $dhcp_installed_result"
	echo "2.2.6 Ensure DNS Server is not installed: $dns_installed_result"
	echo "2.2.7 Ensure FTP Server is not installed: $ftp_installed_result"
	echo "2.2.8 Ensure VSFTP Server is not installed: $vsftpd_installed_result"
	echo "2.2.8 Ensure TFTP Server is not installed: $tftp_installed_result"
	echo "2.2.10 Ensure a web server is not installed: $web_server_installed_result"
	echo "2.2.11 Ensure IMAP and POP3 server is not installed: $imap_pop3_installed_result"
	echo "2.2.12 Ensure Samba is not installed: $samba_installed_result"
	echo "2.2.13 Ensure HTTP Proxy Server is not installed: $squid_installed_result"
	echo "2.2.14 Ensure net-snmp is not installed: $net_snmp_installed_result"
	echo "2.2.15 Ensure NIS server is not installed: $nis_installed_result"
	echo "2.2.16 Ensure telnet-server is not installed: $telnet_installed_result"	
	echo "2.2.17 Ensure mail transfer agent is configured for local-only mode: $telnet_installed_result"
	echo "2.2.18 Ensure nfs-utils is not installed or the  nfs-server service is masked: $nfs_utils_installed_result"
	echo "2.2.19 Ensure rpcbind is not installed or the  rpcbind services are masked: $rpcbind_installed_masked_result"
	echo "2.2.20 Ensure rsync is not installed or the rsyncd service is masked: $rsync_installed_masked_result"
	echo "2.3.1 Ensure NIS Client is not installed: $nis_client_installed_result"
	echo "2.3.2 Ensure rsh client is not installed: $rsh_client_installed_result"
	echo "2.3.3 Ensure talk client is not installed: $talk_client_result"
	echo "2.3.4 Ensure telnet client is not installed: $telnet_client_result"
	echo "2.3.5 Ensure LDAP client is not installed: $ldap_client_installed_result"
	echo "2.3.6 Ensure TFTP client is not installed: $tftp_client_installed_result"
	echo "3.2.1 Ensure IP forwarding is disabled: $ip_forwarding_overall_result"
	echo "3.2.2 Ensure packet redirect sending is disabled: $ip_redirect_overall_result"
	echo "3.3.1 Ensure source routed packets are not accepted: $source_routed_packets_pass_overall_result"
	echo "3.3.2 Ensure ICMP redirects are not accepted: $icmp_redirect_overall_result"
	echo "3.3.3 Ensure secure ICMP redirects are not accepted: $secure_icmp_overall_result"
	echo "3.3.4 Ensure suspicious packets are logged: $suspicious_packets_logged_overall_result"
	echo "3.3.5 Ensure broadcast ICMP requests are ignored: $broadcast_ICMP_request_result"
	echo "3.3.6 Ensure bogus ICMP responses are ignored: $icmp_ignore_bogus_error_result"
	echo "3.3.7 Ensure Reverse Path Filtering is enabled: $reverse_path_filtering_result"
	echo "3.3.8 Ensure TCP SYN Cookies is enabled: $tcp_syn_cookies_result"
	echo "3.3.9 Ensure IPv6 router advertisements are not accepted: $ipv6_router_advertisements_result"
	echo "3.4.1.1 Ensure firewalld is installed: $firewalld_result"
	echo "3.4.1.2 Ensure iptables-services not installed with firewalld: $iptables_services_installed_result"
	echo "3.4.1.3 Ensure nftables either not installed or masked with firewalld: $nftables_installed_masked_result"
	echo "3.4.1.4 Ensure firewalld service enabled and running: $firewalld_service_enabled_running_result"
	echo "3.4.2.1 Ensure nftables is installed: $nftables_installed_result"
	echo "3.4.2.2 Ensure firewalld is either not installed or masked with nftables: $firewalld_installed_masked_result"
	echo "3.4.2.3 Ensure iptables-services not installed with nftables: $iptables_services_installed_result"
	echo "3.4.2.5 Ensure an nftables table exists: $nftables_tables_exists_result"
	echo "3.4.2.6 Ensure nftables base chains exist: $nftables_base_chains_result"
	echo "3.4.2.7 Ensure nftables loopback traffic is configured: $nftables_loopback_traffic_result"
	echo "3.4.2.9 Ensure nftables default deny firewall policy: $nftables_default_deny_firewall_result"
	echo "3.4.2.10 Ensure nftables service is enabled: $nftables_service_result"
	echo "3.4.3.1.1	Ensure iptables packages are installed: $iptables_pckage_installed_result"
	echo "3.4.3.1.2 Ensure nftables is not installed with iptables: $nftables_installed_iptables_result"
	echo "3.4.3.1.3 Ensure firewalld is either not installed or masked with iptables: $firewalld_installed_masked_iptables_result"
	echo "3.4.3.2.1 Ensure iptables loopback traffic is configured: $iptables_loopback_traffic_result"
	echo "3.4.3.2.3 Ensure iptables rules exist for all open ports: $iptables_rules_exists_result"
	echo "3.4.3.2.6 Ensure iptables is enabled and active: $iptables_enable_active_result"
	echo "3.4.3.3.1 Ensure ip6tables loopback traffic is configured: $ip6tables_loopback_traffic_result"
	echo "3.4.3.3.3 Ensure ip6tables firewall rules exist for all open ports: $ip6tables_firewall_rules_result"
	echo "3.4.3.3.4 Ensure ip6tables default deny firewall policy: $ip6tables_default_deny_firewall_result"
	echo "4.2.3 Ensure permissions on all logfiles are configured: $permission_logfiles_result"
	echo "4.2.1.1 Ensure rsyslog is installed: $rsyslog_installed_result"
	echo "4.2.1.2 Ensure rsyslog service is enabled: $rsyslog_service_enabled_result"
	echo "4.2.1.4 Ensure rsyslog default file permissions are configured: $rsyslog_default_file_permission_result"
	echo "4.2.1.7 Ensure rsyslog is not configured to recieve logs from a remote client: $rsyslog_not_configured_receive_log_result"
	echo "4.2.2.2 Ensure journald service is enabled: $journald_enabled_result"
	echo "4.2.2.3 Ensure journald is configured to compress large log files: $journald_configured_compress_result"
	echo "4.2.2.1.4 Ensure journald is not configured to recieve logs from a remote client: $journald_configured_receive_log_result"
	echo "5.1.1 Ensure cron daemon is enabled: $cron_daeemon_enabled_result"
	echo "5.1.2 Ensure permissions on /etc/crontab are configured: $crontab_permission_configured_result"
	echo "5.1.3 Ensure permissions on /etc/cron.hourly are configured: $cronHourly_permission_configured_result"
	echo "5.1.4 Ensure permissions on /etc/cron.daily are configured: $cronDaily_permission_configured_result"
	echo "5.1.5 Ensure permissions on /etc/cron.weekly are configured: $cronWeekly_permission_configured_result"
	echo "5.1.6 Ensure permissions on /etc/cron.monthly are configured: $cronMonthly_permission_configured_result"
	echo "5.1.7 Ensure permissions on /etc/cron.d are configured: $cronD_permission_configured_result"	
	echo "5.1.8 Ensure cron is restricted to authorized users: $cron_restricted_authorized_user_result"
	echo "5.1.9 Ensure at is restricted to authorized users: $at_restricted_authorized_user_result"
	echo "5.2.1 Ensure permissions on /etc/ssh/sshd_config are configured: $sshd_config_permission_configured_result"
	echo "5.2.2 Ensure permissions on SSH private host key files are configured: $sshd_private_key_configured_result"
	echo "5.2.3 Ensure permissions on SSH public host key files are configured: $ssh_public_key_configured_result"
	echo "5.2.4 Ensure SSH access is limited: $ssh_access_limited_result"
	echo "5.2.5 Ensure SSH LogLevel is appropriate: $ssh_loglevel_appropriate_result"
	echo "5.2.6 Ensure SSH PAM is enabled: $ssh_PAM_enable_result"
	echo "5.2.7 Ensure SSH root login is disabled: $ssh_root_login_result"
	echo "5.2.8 Ensure SSH HostbasedAuthentication is disabled: $ssh_hostBasedAuthentication_result"
	echo "5.2.9 Ensure SSH PermitEmptyPasswords is disabled: $ssh_PermitEmptyPassword_result"
	echo "5.2.10 Ensure SSH PermitUserEnvironment is disabled: $ssh_PermitUserEnvironment_result"
	echo "5.2.11 Ensure SSH IgnoreRhosts is enabled: $ssh_IgnoreRhosts_result"
	echo "5.2.14 Ensure system-wide crypto policy is not over-ridden: $system_wide_crypto_policy_result"
	echo "5.2.15 Ensure SSH warning banner is configured: $ssh_warning_banner_result"
	echo "5.2.16 Ensure SSH MaxAuthTries is set to 4 or less: $ssh_MaxAuthTries_result"
	echo "5.2.17 Ensure SSH MaxStartups is configured: $ssh_MaxStartups_result"
	echo "5.2.18 Ensure SSH MaxSessions is set to 10 or less: $ssh_MaxSessions_result"
	echo "5.2.19 Ensure SSH LoginGraceTime is set to one minute or less: $ssh_LoginGraceTime_result"
	echo "5.2.20 Ensure SSH Idle Timeout Interval is configured: $ssh_idle_timeout_result"
	echo "5.3.1 Ensure sudo is installed: $sudo_installed_result"
	echo "5.3.2 Ensure sudo commands use pty: $sudo_command_use_pty_result"
	echo "5.3.3 Ensure sudo log file exists: $sudo_log_file_result"
	echo "5.3.5 Ensure re-authentication for privilege escalation is not disabled globally: $reauthentication_priv_escalation_result"
	echo "5.3.6 Ensure sudo authentication timeout is configured correctly: $sudo_auth_timeout_result"
	echo "5.3.7 Ensure access to the su command is restricted: $su_command_access_result"
	echo "5.5.1 Ensure password creation requirements are configured: $password_creation_requirement_result"
	echo "5.5.2 Ensure lockout for failed password attempts is configured: $lockout_for_failed_password_result"
	echo "5.5.3 Ensure password reuse is limited: $password_reuse_limit_result"
	echo "5.5.4 Ensure password hashing algorithm is SHA-512: $password_hashing_algorithm_result"
	echo "5.6.2 Ensure system accounts are secured: $system_account_secure_result"
	echo "5.6.3 Ensure default user shell timeout is 900 seconds or less: $user_shell_timeout_result"
	echo "5.6.4 Ensure default group for the root account is GID 0: $default_group_for_root_result"
	echo "5.6.5 Ensure default user umask is 027 or more restrictive: $default_user_umask_result"
	echo "5.6.1.1 Ensure password expiration is 365 days or less: $password_expired_365_result"
	echo "5.6.1.2 Ensure minimum days between password changes is 7 or more: $minimum_day_pass_change_result"
	echo "5.6.1.3 Ensure password expiration warning days is 7 or more: $pass_expired_warn_date_result"
	echo "5.6.1.4 Ensure inactive password lock is 30 days or less: $inactive_pass_lock_result"
	echo "5.6.1.5 Ensure all users last password change date is in the past: $user_last_pass_change_result"
	echo "6.1.2 Ensure sticky bit is set on all world-writable directories: $sticky_bit_world_writable_directory_result"
	echo "6.1.3 Ensure permissions on /etc/passwd are configured: $permission_etc_passwd_result"
	echo "6.1.4 Ensure permissions on /etc/shadow are configured: $permission_etc_shadow_result"
	echo "6.1.5 Ensure permissions on /etc/group are configured: $permission_etc_group_result"
	echo "6.1.6 Ensure permissions on /etc/gshadow are configured: $permission_etc_gshadow_result"
	echo "6.1.7 Ensure permissions on /etc/passwd- are configured: $permission_etc_passwd__result"
	echo "6.1.8 Ensure permissions on /etc/shadow- are configured: $permission_etc_shadow__result"
	echo "6.1.9 Ensure permissions on /etc/group- are configured: $permission_etc_group__result"
	echo "6.1.10 Ensure permissions on /etc/gshadow- are configured: $permission_etc_gshadow__result"
	echo "6.1.11 Ensure no world writable files exist: $no_world_writable_exist_result"
	echo "6.1.12 Ensure no unowned files or directories exist: $no_unowned_file_directory_result"
	echo "6.1.13 Ensure no ungrouped files or directories exist: $no_ungrouped_file_directory_result"
	echo "6.2.1 Ensure password fields are not empty: $password_field_empty_result"
	echo "6.2.2 Ensure all groups in /etc/passwd exist in /etc/group: $group_passwd_exist_group_result"
	echo "6.2.3 Ensure no duplicate UIDs exist: $duplicate_uid_exist_result"
	echo "6.2.4 Ensure no duplicate GIDs exist: $duplicate_gid_exist_result"
	echo "6.2.5 Ensure no duplicate user names exist: $duplicate_username_exist_result"
	echo "6.2.6 Ensure no duplicate group names exist: $duplicate_groupname_exist_result"
	echo "6.2.7 Ensure root PATH Integrity: $root_path_integrity_result"
	echo "6.2.8 Ensure root is the only UID 0 account: $root_uid_0_result"
	echo "6.2.9 Ensure all users' home directories exist: $users_home_directory_result"
	echo "6.2.10 Ensure users own their home directories: $users_own_home_directory_result"
	echo "6.2.11 Ensure users' home directories permissions are 750 or more restrictive: $users_home_directory_permission_result"
	echo "6.2.12 Ensure users' dot files are not group or world writable: $users_dotFile_not_grp_world_writable_result"
	echo "6.2.13 Ensure users' .netrc Files are not group or world accessible: $users_netrc_group_accessible_result"
	echo "6.2.14 Ensure no users have .forward files: $users_forward_files_result"
	echo "6.2.15 Ensure no users have .netrc files: $users_have_netrc_files_result"
	echo "6.2.16 Ensure no users have .rhosts files: $no_users_have_rhosts_result"




	# Write the results and command outputs to a text file
	{
	echo "================================================================================"
	echo " "
	echo "1.10 Ensure system-wide crypto policy is not legacy"
	echo "Result: $crypto_policy_check_result"
	echo "Command Output:"
	echo "$crypto_policy_check_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.1.1 Ensure mounting of cramfs filesystems is disabled"
	echo "Result: $cramfs_check_result"
	echo "Commands Output:"
	echo "modprobe -n -v cramfs | grep ""^install"":"
	echo "$modprobe_check_output"
	echo ""
	echo "lsmod | grep cramfs:"
	echo "$lsmod_check_output"
	echo ""
	echo "grep -E ""^blacklist\s+cramfs"" /etc/modprobe.d/*:"
	echo "$blacklist_check_output"
	echo ""
	echo "================================================================================"
	echo " "
	echo "1.1.2.1 Ensure /tmp is a separate partition"
	echo "Result: $tmp_separated_partition_result"
	echo "Command Output:"
	echo "findmnt --kernel /tmp: $findmnt_output"
	echo "systemctl is-enabled tmp.mount: $tmp_mounted"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.2.2 Ensure nodev option set on /tmp partition"
	echo "Result: $tmp_partition_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /tmp | grep nodev: $nodev_findmnt_output"
	echo "Is nodev option set for /tmp mount: $nodev_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.2.3 Ensure noexec option set on /tmp partition"
	echo "Result: $tmp_partition_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /tmp | grep noexec: $noexec_findmnt_output"
	echo "Is noexec option set for /tmp mount: $noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.2.4 Ensure nosuid option set on /tmp partition"
	echo "Result: $tmp_partition_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /tmp | grep nosuid: $nosuid_findmnt_output"
	echo "Is nosuid option set for /tmp mount: $nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.3.2 Ensure nodev option set on /var partition"
	echo "Result: $var_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /var | grep nodev: $var_nodev_findmnt_output"
	echo "Is nodev option set for /var mount: $var_nodev_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.3.3 Ensure noexec option set on /var partition"
	echo "Result: $var_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /var | grep noexec: $var_noexec_findmnt_output"
	echo "Is noexec option set for /var mount: $var_noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.3.4 Ensure nosuid option set on /var partition"
	echo "Result: $var_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /var | grep nosuid: $var_nosuid_findmnt_output"
	echo "Is nosuid option set for /var mount: $var_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.4.2 Ensure noexec option set on /var/tmp partition"
	echo "Result: $var_tmp_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/tmp | grep noexec: $var_tmp_noexec_findmnt_output"
	echo "Is noexec option set for /var/tmp mount: $var_tmp_noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.4.3 Ensure nosuid option set on /var/tmp partition"
	echo "Result: $var_tmp_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/tmp | grep nosuid: $var_tmp_nosuid_findmnt_output"
	echo "Is nosuid option set for /var/tmp mount: $var_tmp_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.4.4 Ensure nodev option set on /var/tmp partition"
	echo "Result: $var_tmp_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/tmp | grep nodev: $var_tmp_nosuid_findmnt_output"
	echo "Is nodev option set for /var/tmp mount: $var_tmp_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.5.2 Ensure nodev option set on /var/log partition"
	echo "Result: $var_log_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log | grep nodev: $var_log_nodev_findmnt_output"
	echo "Is nodev option set for /var/log mount: $var_log_nodev_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.5.3 Ensure noexec option set on /var/log partition"
	echo "Result: $var_log_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log | grep noexec: $var_log_noexec_findmnt_output"
	echo "Is noexec option set for /var/log mount: $var_log_noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.5.4 Ensure nosuid option set on /var/log partition"
	echo "Result: $var_log_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log | grep nosuid: $var_log_nosuid_findmnt_output"
	echo "Is nosuid option set for /var/log mount: $var_log_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.6.2 Ensure noexec option set on /var/log/audit partition"
	echo "Result: $var_log_audit_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log/audit | grep noexec: $var_log_audit_noexec_findmnt_output"
	echo "Is noexec option set for /var/log/audit mount: $var_log_audit_noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.6.3 Ensure nodev option set on /var/log/audit partition"
	echo "Result: $var_log_audit_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log/audit | grep nodev: $var_log_audit_nodev_findmnt_output"
	echo "Is nodev option set for /var/log/audit mount: $var_log_audit_nodev_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.6.4 Ensure nosuid option set on /var/log/audit partition"
	echo "Result: $var_log_audit_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /var/log/audit | grep nosuid: $var_log_audit_nosuid_findmnt_output"
	echo "Is nodev option set for /var/log/audit mount: $var_log_audit_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.7.2 Ensure nodev option set on /home partition"
	echo "Result: $home_nodev_result"
	echo "Command Output:"
	echo "findmnt --kernel /home | grep nodev: $home_nodev_findmnt_output"
	echo "Is nodev option set for /home mount: $home_nodev_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.7.3 Ensure nosuid option set on /home partition"
	echo "Result: $home_nosuid_result"
	echo "Command Output:"
	echo "findmnt --kernel /home | grep nosuid: $home_nosuid_findmnt_output"
	echo "Is nodev option set for /home mount: $home_nosuid_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.7.4 Ensure usrquota option set on /home partition"
	echo "Result: $home_usrquota_result"
	echo "Command Output:"
	echo "findmnt --kernel /home | grep usrquota: $home_usrquota_findmnt_output"
	echo "Is nodev option set for /home mount: $home_usrquota_option_set"
	echo "quotaon -p /home | grep user: $home_quotaon_output"
	echo "Check if user quotas are enabled for /home: $home_user_quotas_enabled"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.7.5 Ensure grpquota option set on /home partition"
	echo "Result: $home_grpquota_result"
	echo "Command Output:"
	echo "findmnt --kernel /home | grep grpquota: $home_grpquota_findmnt_output"
	echo "Is nodev option set for /home mount: $home_grpquota_option_set"
	echo "quotaon -p /home | grep user: $home_grp_quotaon_output"
	echo "Check if user quotas are enabled for /home: $home_group_quotas_enabled"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.8.1 Ensure nodev option set on /dev/shm partition"
	echo "Result: $dev_shm_nodev_result"
	echo "Command Output:"
	echo "mount | grep -E '\s/dev/shm\s' | grep -v nodev: $dev_shm_nodev_mount_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.8.2 Ensure noexec option set on /dev/shm partition"
	echo "Result: $dev_shm_noexec_result"
	echo "Command Output:"
	echo "findmnt --kernel /dev/shm | grep noexec: $dev_shm_noexec_findmnt_output"
	echo "Check if noexec option is set for /dev/shm mount: $dev_shm_noexec_option_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.1.8.3 Ensure nosuid option set on /dev/shm partition"
	echo "Result: $dev_shm_nosuid_result"
	echo "Command Output:"
	echo "mount | grep -E '\s/dev/shm\s' | grep -v nosuid: $dev_shm_nosuid_mount_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.2.2 Ensure gpgcheck is globally activated"
	echo "Result: $gpgcheck_result"
	echo "Command Output:"
	echo "grep ^gpgcheck /etc/dnf/dnf.conf | awk -F '=' '{print $2}' | tr -d ' ': $global_gpgcheck"
	echo "grep \"^gpgcheck\s*=\" /etc/yum.repos.d/* | grep -vE \"^#|gpgcheck\s*= 1$\": "
	echo "$invalid_gpgcheck_entries"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.3.1 Ensure AIDE is installed"
	echo "Result: $aide_result"
	echo "Command Output:"
	echo "rpm -q aide: "
	echo "$aide_installed"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.3.2 Ensure filesystem integrity is regularly checked"
	echo "Result: $filesystem_integrity_result"
	echo "Command Output:"
	echo "grep -Ers '^([^#]+\s+)?(\/usr\/s?bin\/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' /etc/cron.* /etc/crontab /var/spool/cron/: "
	echo "$aide_cron_job"; echo ""
	echo "systemctl is-enabled aidecheck.service: "
	echo "$aide_service_enabled"; echo ""
	echo "systemctl is-enabled aidecheck.timer: "
	echo "$aide_timer_enabled"; echo ""
	echo "systemctl status aidecheck.timer: "
	echo "$aide_timer_status"; echo ""
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.4.1 Ensure bootloader password is set:"
	echo "Result: $bootloader_passwd_set"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.4.2 Ensure permissions on bootloader config are configured:"
	echo "Result: $bootloader_permission_config_result"
	echo "Command Output:"
	echo "Check permissions: "
	echo "$boootloader_perm_output"
	echo "$boootloader_perm_output3"
	echo "Check ownership and group"
	echo "$boootloader_perm_output2"
	echo "$boootloader_perm_output4"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.4.3 Ensure authentication is required when booting into rescue mode"
	echo "Result: $auth_booting_in_rescue_mode_result"
	echo "Command Output:"
	echo "grep -r '/systemd-sulogin-shell' /usr/lib/systemd/system/rescue.service /etc/systemd/system/rescue.service.d:"
	echo "$auth_booting_in_rescue_mode"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.5.1 Ensure core dump storage is disabled "
	echo "Result: $core_dump_storage_result"
	echo "Command Output:"
	echo "grep -i '^\s*storage\s*=\s*none' /etc/systemd/coredump.conf:"
	echo "$core_dump_storage_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.5.2 Ensure core dump backtraces are disabled"
	echo "Result: $core_dump_backtraces_result"
	echo "Command Output:"
	echo "grep -i '^\s*ProcessSizeMax\s*=\s*0' /etc/systemd/coredump.conf:"
	echo "$core_dump_backtraces_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.5.3 Ensure address space layout randomization (ASLR) is enabled"
	echo "Result: $aslr_result"
	echo "Command Output:"
	echo "$aslr_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.1 Ensure SELinux is installed"
	echo "Result: $SElinux_rpm_result"
	echo "Command Output:"
	echo "$SeLinux_rpm_output"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.2 Ensure SELinux is not disabled in bootloader configuration"
	echo "Result: $SElinux_not_disabled_bootloader_config_result"
	echo "Command Output:"
	echo "grep -P -- '^\h*(kernelopts=|linux|kernel)' $(find /boot -type f \( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \) -exec grep -Pl -- '^\h*(kernelopts=|linux|kernel)' {} \;) | grep -E -- '(selinux=0|enforcing=0)':"
	echo "$SElinux_not_disabled_bootloader_config_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.3 Ensure SELinux policy is configured"
	echo "Result: $seLinux_policy_result"
	echo "Command Output:"
	echo "grep -E '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config"
	echo "$seLinux_policy_config_output"
	echo "sestatus | grep \"Loaded policy name\""
	echo "$seLinux_policy_sestatus_output"
	echo "$seLinux_policy_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.4 Ensure the SELinux mode is not disabled"
	echo "Result: $seLinux_configured_result"
	echo "Command Output:"
	echo "getenforce"
	echo "$seLinux_current_mode"
	echo "grep -Ei '^\s*SELINUX=(enforcing|permissive)' /etc/selinux/config"
	echo "$seLinux_configured_mode"
	echo "$seLinux_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.6 Ensure no unconfined services exist"
	echo "Result: $no_confined_services_result"
	echo "Command Output:"
	echo "ps -eZ | grep unconfined_service_t:"
	echo "$no_confined_services_output"
	echo "$no_confined_services_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.6.1.8 Ensure the MCS Translation Service (mcstrans) is not installed"
	echo "Result: $mcstrans_result"
	echo "Command Output:"
	echo "rpm -q mcstrans:"
	echo "$mcstrans_output"
	echo "$mcstrans_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.1 Ensure message of the day is configured properly"
	echo "Result: $motd_result"
	echo "Command Output:"
	echo "cat /etc/motd:"
	echo "$motd_content"
	echo "grep -E -i \"(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"\"//g'))\" /etc/motd:"
	echo "$motd_content_grep_result"
	echo "$motd_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.2 Ensure local login warning banner is configured properly"
	echo "Result: $issue_content_result"
	echo "Command Output:"
	echo "cat /etc/issue:"
	echo "$issue_content"
	echo "grep -E -i \"(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"\"//g'))\" /etc/issue:"
	echo "$issue_content_grep_result"
	echo "$issue_content_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.3 Ensure remote login warning banner is configured properly"
	echo "Result: $remote_login_warning_result"
	echo "Command Output:"
	echo "cat /etc/issue.net:"
	echo "$remote_login_warning_issue_net_content"
	echo "grep -E -i \"(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"\"//g'))\" /etc/issue.net:"
	echo "$remote_login_warning_grep_result"
	echo "$remote_login_warning_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.4 Ensure permissions on /etc/motd are configured"
	echo "Result: $etc_motd_result"
	echo "Command Output:"
	echo "stat /etc/motd | grep Access | grep uid:"
	echo "$etc_motd_permissions"
	echo "$etc_motd_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.5 Ensure permissions on /etc/issue are configured"
	echo "Result: $etc_issue_result"
	echo "Command Output:"
	echo "stat /etc/issue | grep Access | grep uid:"
	echo "$etc_issue_permissions"
	echo "$etc_issue_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.7.6 Ensure permissions on /etc/issue.net are configured"
	echo "Result: $etc_issueNet_result"
	echo "Command Output:"
	echo "stat /etc/issue.net | grep Access | grep uid:"
	echo "$etc_issueNet_permissions"
	echo "$etc_issueNet_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.8.2 Ensure GDM login banner is configured"
	echo "Result: $gdm_overall_result"
	echo "Command Output:"
	echo "/etc/dconf/profile/gdm:"
	echo "$gdm_profile_message"
	echo "/etc/dconf/db/gdm.d/01-banner-message:"
	echo "$gdm_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.8.3 Ensure last logged in user display is disabled"
	echo "Result: $last_login_result"
	echo "Command Output:"
	echo "/etc/dconf/profile/gdm:"
	echo "$profile_message"
	echo "/etc/dconf/db/gdm.d/00-login-screen:"
	echo "$last_login_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "1.8.4 Ensure XDMCP is not enabled"
	echo "Result: $xdmcp_result"
	echo "Command Output:"
	echo "grep -Eis '^\s*Enable\s*=\s*true' /etc/gdm/custom.conf:"
	echo "$xdmcp_output"
	echo "xdmcp_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.1.1 Ensure time synchronization is in use"
	echo "Result: $chrony_installed_result"
	echo "Command Output:"
	echo "rpm -q chrony:"
	echo "$chrony_rpm_output"
	echo "$chrony_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.1.2 Ensure chrony is configured"
	echo "Result: $chrony_config_result"
	echo "Command Output:"
	echo "grep -E \"^(server|pool)\" /etc/chrony.conf:"
	echo "$chrony_remote_server"
	echo "$chrony_remote_server_message"
	echo "grep ^OPTIONS /etc/sysconfig/chronyd | grep -q '\-u chrony' && echo "true" || echo "false""
	echo "$chrony_config_options"
	echo "$chrony_config_options_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.1 Ensure xinetd is not installed"
	echo "Result: $xinetd_result"
	echo "Command Output:"
	echo "rpm -q xinetd &> /dev/null:"
	echo "$xinetd_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.5 Ensure DHCP Server is not installed"
	echo "Result: $dhcp_installed_result"
	echo "Command Output:"
	echo "rpm -q dhcp-server &> /dev/null:"
	echo "$dhcp_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.6 Ensure DNS Server is not installed"
	echo "Result: $dns_installed_result"
	echo "Command Output:"
	echo "rpm -q dhcp-server &> /dev/null:"
	echo "$dns_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.7 Ensure FTP Server is not installed"
	echo "Result: $ftp_installed_result"
	echo "Command Output:"
	echo "rpm -q ftp &> /dev/null:"
	echo "$ftp_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.8 Ensure VSFTP Server is not installed"
	echo "Result: $vsftpd_installed_result"
	echo "Command Output:"
	echo "rpm -q vsftpd &> /dev/null:"
	echo "$vsftpd_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.9 Ensure TFTP Server is not installed"
	echo "Result: $tftp_installed_result"
	echo "Command Output:"
	echo "rpm -q tftp &> /dev/null:"
	echo "$tftp_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.10 Ensure a web server is not installed"
	echo "Result: $web_server_installed_result"
	echo "Command Output:"
	echo "rpm -q httpd &> /dev/null && rpm -q nginx &> /dev/null:"
	echo "$web_server_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.11 Ensure IMAP and POP3 server is not installed"
	echo "Result: $imap_pop3_installed_result"
	echo "Command Output:"
	echo "rpm -q dovecot &> /dev/null && rpm -q cyrus-imapd &> /dev/null:"
	echo "$imap_pop3_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.12 Ensure Samba is not installed"
	echo "Result: $samba_installed_result"
	echo "Command Output:"
	echo "rpm -q samba &> /dev/null:"
	echo "$samba_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.13 Ensure HTTP Proxy Server is not installed"
	echo "Result: $squid_installed_result"
	echo "Command Output:"
	echo "rpm -q squid &> /dev/null:"
	echo "$squid_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.14 Ensure net-snmp is not installed"
	echo "Result: $net_snmp_installed_result"
	echo "Command Output:"
	echo "rpm -q net-snmp &> /dev/null:"
	echo "$net_snmp_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.15 Ensure NIS server is not installed"
	echo "Result: $nis_installed_result"
	echo "Command Output:"
	echo "rpm -q ypserv &> /dev/null:"
	echo "$nis_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.16 Ensure telnet-server is not installed"
	echo "Result: $telnet_installed_result"
	echo "Command Output:"
	echo "rpm -q telnet-server &> /dev/null:"
	echo "$telnet_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.17 Ensure mail transfer agent is configured for local-only mode"
	echo "Result: $telnet_installed_result"
	echo "Command Output:"
	echo "rpm -q telnet-server &> /dev/null:"
	echo "$telnet_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.18 Ensure nfs-utils is not installed or the  nfs-server service is masked"
	echo "Result: $nfs_utils_installed_result"
	echo "Command Output:"
	echo "rpm -q nfs-utils &> /dev/null:"
	echo "$nfs_utils_installed_message"
	echo "systemctl is-enabled nfs-server | grep -q masked:"
	echo "$nfs_server_enabled_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.19 Ensure rpcbind is not installed or the  rpcbind services are masked"
	echo "Result: $rpcbind_installed_masked_result"
	echo "Command Output:"
	echo "rpm -q rpcbind &> /dev/null:"
	echo "$rpcbind_installed_message"
	echo "systemctl is-enabled rpcbind | grep -q masked:"
	echo "$rpcbind_masked_message"
	echo "systemctl is-enabled rpcbind.socket | grep -q masked:"
	echo "$rpcbind_socket_masked_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.2.20 Ensure rsync is not installed or the rsyncd service is masked"
	echo "Result: $rsync_installed_masked_result"
	echo "Command Output:"
	echo "rpm -q rsync &> /dev/null:"
	echo "$rsync_installed_message"
	echo "systemctl is-enabled rsyncd | grep -q masked:"
	echo "$rsyncd_masked_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.1 Ensure NIS Client is not installed"
	echo "Result: $nis_client_installed_result"
	echo "Command Output:"
	echo "rpm -q ypbind &> /dev/null:"
	echo "$nis_client_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.2 Ensure rsh client is not installed"
	echo "Result: $rsh_client_installed_result"
	echo "Command Output:"
	echo "rpm -q rsh &> /dev/null:"
	echo "$rsh_client_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.3 Ensure talk client is not installed"
	echo "Result: $talk_client_result"
	echo "Command Output:"
	echo "rpm -q talk &> /dev/null:"
	echo "$talk_client_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.4 Ensure telnet client is not installed"
	echo "Result: $telnet_client_result"
	echo "Command Output:"
	echo "rpm -q telnet &> /dev/null:"
	echo "$telnet_client_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.5 Ensure LDAP client is not installed"
	echo "Result: $ldap_client_installed_result"
	echo "Command Output:"
	echo "rpm -q openldap-clients &> /dev/null:"
	echo "$ldap_client_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "2.3.6 Ensure TFTP client is not installed"
	echo "Result: $tftp_client_installed_result"
	echo "Command Output:"
	echo "rpm -q tftp &> /dev/null:"
	echo "$tftp_client_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.2.1 Ensure IP forwarding is disabled"
	echo "Result: $ip_forwarding_overall_result"
	echo "Command Output:"
	echo "IPv4 fowarding result: $ipv4_forwarding_result"
	echo "$ipv4_forwarding_message"
	echo " "
	echo "IPv6 fowarding result: $ipv4_forwarding_result"
	echo "$ipv6_forwarding_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.2.2 Ensure packet redirect sending is disabled"
	echo "Result: $ip_redirect_overall_result"
	echo "Command Output:"
	echo "Check net.ipv4.conf.all.send_redirects"
	echo -e "$ipv4_redirect_all_message"
	echo " "
	echo "Check net.ipv4.conf.default.send_redirects"
	echo -e "$ipv4_redirect_default_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.1 Ensure source routed packets are not accepted"
	echo "Result: $source_routed_packets_pass_overall_result"
	echo "Command Output:"
	echo "Check net.ipv4.conf.all.send_redirects"
	echo -e "$source_routed_packets_pass_result"
	echo -e "$source_routed_packets_fail_result"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.2 Ensure ICMP redirects are not accepted"
	echo "Result: $icmp_redirect_overall_result"
	echo "Command Output:"
	echo ""
	echo -e "$icmp_redirect_result"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.3 Ensure secure ICMP redirects are not accepted"
	echo "Result: $secure_icmp_overall_result"
	echo "Command Output:"
	echo ""
	echo -e "$secure_icmp_result"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.4 Ensure suspicious packets are logged"
	echo "Result: $suspicious_packets_logged_overall_result"
	echo "Command Output:"
	echo ""
	echo -e "$suspicious_packets_logged_result_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.5 Ensure broadcast ICMP requests are ignored"
	echo "Result: $broadcast_ICMP_request_result"
	echo "Command Output:"
	echo ""
	echo -e "$broadcast_ICMP_request_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.6 Ensure bogus ICMP responses are ignored"
	echo "Result: $icmp_ignore_bogus_error_result"
	echo "Command Output:"
	echo ""
	echo -e "$icmp_ignore_bogus_error_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.7 Ensure Reverse Path Filtering is enabled"
	echo "Result: $reverse_path_filtering_result"
	echo "Command Output:"
	echo ""
	echo -e "$reverse_path_filtering_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.8 Ensure TCP SYN Cookies is enabled"
	echo "Result: $tcp_syn_cookies_result"
	echo "Command Output:"
	echo ""
	echo -e "$tcp_syn_cookies_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.3.9 Ensure IPv6 router advertisements are not accepted"
	echo "Result: $ipv6_router_advertisements_result"
	echo "Command Output:"
	echo ""
	echo -e "$ipv6_router_advertisements_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.1.1 Ensure firewalld is installed"
	echo "Result: $firewalld_result"
	echo "Command Output:"
	echo ""
	echo -e "$firewalld_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.1.2 Ensure iptables-services not installed with firewalld"
	echo "Result: $iptables_services_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_services_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.1.3 Ensure nftables either not installed or masked with firewalld"
	echo "Result: $nftables_installed_masked_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_installed_masked_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.1.4 Ensure firewalld service enabled and running"
	echo "Result: $firewalld_service_enabled_running_result"
	echo "Command Output:"
	echo ""
	echo -e "$firewalld_service_enabled_running_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.1 Ensure nftables is installed"
	echo "Result: $nftables_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.2 Ensure firewalld is either not installed or masked with nftables"
	echo "Result: $firewalld_installed_masked_result"
	echo "Command Output:"
	echo ""
	echo -e "$firewalld_installed_masked_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.3 Ensure iptables-services not installed with nftables"
	echo "Result: $iptables_services_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_services_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.5 Ensure an nftables table exists"
	echo "Result: $nftables_tables_exists_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_tables_exists_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.6 Ensure nftables base chains exist"
	echo "Result: $nftables_base_chains_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_base_chains_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.7 Ensure nftables loopback traffic is configured"
	echo "Result: $nftables_loopback_traffic_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_loopback_traffic_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.9 Ensure nftables default deny firewall policy"
	echo "Result: $nftables_default_deny_firewall_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_default_deny_firewall_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.2.10 Ensure nftables service is enabled"
	echo "Result: $nftables_service_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_service_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.1.1	Ensure iptables packages are installed"
	echo "Result: $iptables_pckage_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_pckage_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.1.2 Ensure nftables is not installed with iptables"
	echo "Result: $nftables_installed_iptables_result"
	echo "Command Output:"
	echo ""
	echo -e "$nftables_installed_iptables_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.1.3 Ensure firewalld is either not installed or masked with iptables"
	echo "Result: $firewalld_installed_masked_iptables_result"
	echo "Command Output:"
	echo ""
	echo -e "$firewalld_installed_masked_iptables_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.2.1 Ensure iptables loopback traffic is configured"
	echo "Result: $iptables_loopback_traffic_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_loopback_traffic_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.2.3 Ensure iptables rules exist for all open ports"
	echo "Result: $iptables_rules_exists_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_rules_exists_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.2.4 Ensure iptables default deny firewall policy"
	echo "Result: $iptables_default_deny_firewall_policy_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_default_deny_firewall_policy_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.2.6 Ensure iptables is enabled and active"
	echo "Result: $iptables_enable_active_result"
	echo "Command Output:"
	echo ""
	echo -e "$iptables_enable_active_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.3.1 Ensure ip6tables loopback traffic is configured"
	echo "Result: $ip6tables_loopback_traffic_result"
	echo "Command Output:"
	echo ""
	echo -e "$ip6tables_loopback_traffic_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.3.3 Ensure ip6tables firewall rules exist for all open ports"
	echo "Result: $ip6tables_firewall_rules_result"
	echo "Command Output:"
	echo ""
	echo -e "$ip6tables_firewall_rules_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.3.4 Ensure ip6tables default deny firewall policy"
	echo "Result: $ip6tables_default_deny_firewall_result"
	echo "Command Output:"
	echo ""
	echo -e "$ip6tables_default_deny_firewall_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.3.5 Ensure ip6tables rules are saved"
	echo "Result: $ip6tables_rule_saved_result"
	echo "Command Output:"
	echo ""
	echo -e "$ip6tables_rule_saved_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "3.4.3.3.6 Ensure ip6tables is enabled and active"
	echo "Result: $ip6tables_enabled_active_result"
	echo "Command Output:"
	echo ""
	echo -e "$ip6tables_enabled_active_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.3 Ensure permissions on all logfiles are configured"
	echo "Result: $permission_logfiles_result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_logfiles_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.1.1 Ensure rsyslog is installed"
	echo "Result: $rsyslog_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$rsyslog_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.1.2 Ensure rsyslog service is enabled"
	echo "Result: $rsyslog_service_enabled_result"
	echo "Command Output:"
	echo ""
	echo -e "$rsyslog_service_enabled_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.1.4 Ensure rsyslog default file permissions are configured"
	echo "Result: $rsyslog_default_file_permission_result"
	echo "Command Output:"
	echo ""
	echo -e "$rsyslog_default_file_permission_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.1.7 Ensure rsyslog is not configured to recieve logs from a remote client"
	echo "Result: $rsyslog_not_configured_receive_log_result"
	echo "Command Output:"
	echo ""
	echo -e "$rsyslog_not_configured_receive_log_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.2.2 Ensure journald service is enabled"
	echo "Result: $journald_enabled_result"
	echo "Command Output:"
	echo ""
	echo -e "$journald_enabled_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.2.3 Ensure journald is configured to compress large log files"
	echo "Result: $journald_configured_compress_result"
	echo "Command Output:"
	echo ""
	echo -e "$journald_configured_compress_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.2.4 Ensure journald is configured to write logfiles to persistent disk"
	echo "Result: $journald_configured_write_log_result"
	echo "Command Output:"
	echo ""
	echo -e "$journald_configured_write_log_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "4.2.2.1.4 Ensure journald is not configured to recieve logs from a remote client"
	echo "Result: $journald_configured_receive_log_result"
	echo "Command Output:"
	echo ""
	echo -e "$journald_configured_receive_log_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.1 Ensure cron daemon is enabled"
	echo "Result: $cron_daeemon_enabled_result"
	echo "Command Output:"
	echo ""
	echo -e "$cron_daeemon_enabled_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.2 Ensure permissions on /etc/crontab are configured"
	echo "Result: $crontab_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$crontab_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.3 Ensure permissions on /etc/cron.hourly are configured"
	echo "Result: $cronHourly_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$cronHourly_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.4 Ensure permissions on /etc/cron.daily are configured"
	echo "Result: $cronDaily_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$cronDaily_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.5 Ensure permissions on /etc/cron.weekly are configured"
	echo "Result: $cronWeekly_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$cronWeekly_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.6 Ensure permissions on /etc/cron.monthly are configured"
	echo "Result: $cronMonthly_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$cronMonthly_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.7 Ensure permissions on /etc/cron.d are configured"
	echo "Result: $cronD_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$cronD_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.8 Ensure cron is restricted to authorized users"
	echo "Result: $cron_restricted_authorized_user_result"
	echo "Command Output:"
	echo ""
	echo -e "$cron_restricted_authorized_user_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.1.9 Ensure at is restricted to authorized users"
	echo "Result: $at_restricted_authorized_user_result"
	echo "Command Output:"
	echo ""
	echo -e "$at_restricted_authorized_user_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.1 Ensure permissions on /etc/ssh/sshd_config are configured"
	echo "Result: $sshd_config_permission_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$sshd_config_permission_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.2 Ensure permissions on SSH private host key files are configured"
	echo "Result: $sshd_private_key_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$sshd_private_key_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.2 Ensure permissions on SSH private host key files are configured"
	echo "Result: $sshd_private_key_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$sshd_private_key_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.3 Ensure permissions on SSH public host key files are configured"
	echo "Result: $ssh_public_key_configured_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_public_key_configured_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.4 Ensure SSH access is limited"
	echo "Result: $ssh_access_limited_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_access_limited_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.5 Ensure SSH LogLevel is appropriate"
	echo "Result: $ssh_loglevel_appropriate_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_loglevel_appropriate_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.6 Ensure SSH PAM is enabled"
	echo "Result: $ssh_PAM_enable_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_PAM_enable_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.7 Ensure SSH root login is disabled"
	echo "Result: $ssh_root_login_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_root_login_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.8 Ensure SSH HostbasedAuthentication is disabled"
	echo "Result: $ssh_hostBasedAuthentication_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_hostBasedAuthentication_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.9 Ensure SSH PermitEmptyPasswords is disabled"
	echo "Result: $ssh_PermitEmptyPassword_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_PermitEmptyPassword_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.10 Ensure SSH PermitUserEnvironment is disabled"
	echo "Result: $ssh_PermitUserEnvironment_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_PermitUserEnvironment_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.11 Ensure SSH IgnoreRhosts is enabled"
	echo "Result: $ssh_IgnoreRhosts_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_IgnoreRhosts_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.14 Ensure system-wide crypto policy is not over-ridden"
	echo "Result: $system_wide_crypto_policy_result"
	echo "Command Output:"
	echo ""
	echo -e "$system_wide_crypto_policy_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.15 Ensure SSH warning banner is configured"
	echo "Result: $ssh_warning_banner_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_warning_banner_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.16 Ensure SSH MaxAuthTries is set to 4 or less"
	echo "Result: $ssh_MaxAuthTries_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_MaxAuthTries_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.17 Ensure SSH MaxStartups is configured"
	echo "Result: $ssh_MaxStartups_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_MaxStartups_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.18 Ensure SSH MaxSessions is set to 10 or less"
	echo "Result: $ssh_MaxSessions_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_MaxSessions_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.19 Ensure SSH LoginGraceTime is set to one minute or less"
	echo "Result: $ssh_LoginGraceTime_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_LoginGraceTime_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.2.20 Ensure SSH Idle Timeout Interval is configured"
	echo "Result: $ssh_idle_timeout_result"
	echo "Command Output:"
	echo ""
	echo -e "$ssh_idle_timeout_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.1 Ensure sudo is installed"
	echo "Result: $sudo_installed_result"
	echo "Command Output:"
	echo ""
	echo -e "$sudo_installed_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.2 Ensure sudo commands use pty"
	echo "Result: $sudo_command_use_pty_result"
	echo "Command Output:"
	echo ""
	echo -e "$sudo_command_use_pty_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.3 Ensure sudo log file exists"
	echo "Result: $sudo_log_file_result"
	echo "Command Output:"
	echo ""
	echo -e "$sudo_log_file_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.5 Ensure re-authentication for privilege escalation is not disabled globally"
	echo "Result: $reauthentication_priv_escalation_result"
	echo "Command Output:"
	echo ""
	echo -e "$reauthentication_priv_escalation_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.6 Ensure sudo authentication timeout is configured correctly"
	echo "Result: $sudo_auth_timeout_result"
	echo "Command Output:"
	echo ""
	echo -e "$sudo_auth_timeout_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.3.7 Ensure access to the su command is restricted"
	echo "Result: $su_command_access_result"
	echo "Command Output:"
	echo ""
	echo -e "$su_command_access_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.5.1 Ensure password creation requirements are configured"
	echo "Result: $password_creation_requirement_result"
	echo "Command Output:"
	echo ""
	echo -e "$password_creation_requirement_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.5.2 Ensure lockout for failed password attempts is configured"
	echo "Result: $lockout_for_failed_password_result"
	echo "Command Output:"
	echo ""
	echo -e "$lockout_for_failed_password_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.5.3 Ensure password reuse is limited"
	echo "Result: $password_reuse_limit_result"
	echo "Command Output:"
	echo ""
	echo -e "$password_reuse_limit_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.5.4 Ensure password hashing algorithm is SHA-512"
	echo "Result: $password_hashing_algorithm_result"
	echo "Command Output:"
	echo ""
	echo -e "$password_hashing_algorithm_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.2 Ensure system accounts are secured"
	echo "Result: $system_account_secure_result"
	echo "Command Output:"
	echo ""
	echo -e "$system_account_secure_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.3 Ensure default user shell timeout is 900 seconds or less"
	echo "Result: $user_shell_timeout_result"
	echo "Command Output:"
	echo ""
	echo -e "$user_shell_timeout_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.4 Ensure default group for the root account is GID 0"
	echo "Result: $default_group_for_root_result"
	echo "Command Output:"
	echo ""
	echo -e "$default_group_for_root_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.5 Ensure default user umask is 027 or more restrictive"
	echo "Result: $default_user_umask_result"
	echo "Command Output:"
	echo ""
	echo -e "$default_user_umask_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.1.1 Ensure password expiration is 365 days or less"
	echo "Result: $password_expired_365_result"
	echo "Command Output:"
	echo ""
	echo -e "$password_expired_365_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.1.2 Ensure minimum days between password changes is 7 or more"
	echo "Result: $minimum_day_pass_change_result"
	echo "Command Output:"
	echo ""
	echo -e "$minimum_day_pass_change_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.1.3 Ensure password expiration warning days is 7 or more"
	echo "Result: $pass_expired_warn_date_result"
	echo "Command Output:"
	echo ""
	echo -e "$pass_expired_warn_date_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.1.4 Ensure inactive password lock is 30 days or less"
	echo "Result: $inactive_pass_lock_result"
	echo "Command Output:"
	echo ""
	echo -e "$inactive_pass_lock_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "5.6.1.5 Ensure all users last password change date is in the past"
	echo "Result: $user_last_pass_change_result"
	echo "Command Output:"
	echo ""
	echo -e "$user_last_pass_change_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.2 Ensure sticky bit is set on all world-writable directories"
	echo "Result: $sticky_bit_world_writable_directory_result"
	echo "Command Output:"
	echo ""
	echo -e "$sticky_bit_world_writable_directory_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.3 Ensure permissions on /etc/passwd are configured"
	echo "Result: $permission_etc_passwd_result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_passwd_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.4 Ensure permissions on /etc/shadow are configured"
	echo "Result: $permission_etc_shadow_result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_shadow_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.5 Ensure permissions on /etc/group are configured"
	echo "Result: $permission_etc_group_result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_group_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.6 Ensure permissions on /etc/gshadow are configured"
	echo "Result: $permission_etc_gshadow_result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_gshadow_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.7 Ensure permissions on /etc/passwd- are configured"
	echo "Result: $permission_etc_passwd__result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_passwd__message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.8 Ensure permissions on /etc/shadow- are configured"
	echo "Result: $permission_etc_shadow__result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_shadow__message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.9 Ensure permissions on /etc/group- are configured"
	echo "Result: $permission_etc_group__result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_group__message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.10 Ensure permissions on /etc/gshadow- are configured"
	echo "Result: $permission_etc_gshadow__result"
	echo "Command Output:"
	echo ""
	echo -e "$permission_etc_gshadow__message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.11 Ensure no world writable files exist"
	echo "Result: $no_world_writable_exist_result"
	echo "Command Output:"
	echo ""
	echo -e "$no_world_writable_exist_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.12 Ensure no unowned files or directories exist"
	echo "Result: $no_unowned_file_directory_result"
	echo "Command Output:"
	echo ""
	echo -e "$no_unowned_file_directory_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.1.13 Ensure no ungrouped files or directories exist"
	echo "Result: $no_ungrouped_file_directory_result"
	echo "Command Output:"
	echo ""
	echo -e "$no_ungrouped_file_directory_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.1 Ensure password fields are not empty"
	echo "Result: $password_field_empty_result"
	echo "Command Output:"
	echo ""
	echo -e "$password_field_empty_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.2 Ensure all groups in /etc/passwd exist in /etc/group"
	echo "Result: $group_passwd_exist_group_result"
	echo "Command Output:"
	echo ""
	echo -e "$group_passwd_exist_group_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.3 Ensure no duplicate UIDs exist"
	echo "Result: $duplicate_uid_exist_result"
	echo "Command Output:"
	echo ""
	echo -e "$duplicate_uid_exist_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.4 Ensure no duplicate GIDs exist"
	echo "Result: $duplicate_gid_exist_result"
	echo "Command Output:"
	echo ""
	echo -e "$duplicate_gid_exist_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.5 Ensure no duplicate user names exist"
	echo "Result: $duplicate_username_exist_result"
	echo "Command Output:"
	echo ""
	echo -e "$duplicate_username_exist_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.6 Ensure no duplicate group names exist"
	echo "Result: $duplicate_groupname_exist_result"
	echo "Command Output:"
	echo ""
	echo -e "$duplicate_groupname_exist_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.7 Ensure root PATH Integrity"
	echo "Result: $root_path_integrity_result"
	echo "Command Output:"
	echo ""
	echo -e "$root_path_integrity_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.8 Ensure root is the only UID 0 account"
	echo "Result: $root_uid_0_result"
	echo "Command Output:"
	echo ""
	echo -e "$root_uid_0_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.9 Ensure all users' home directories exist"
	echo "Result: $users_home_directory_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_home_directory_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.10 Ensure users own their home directories"
	echo "Result: $users_own_home_directory_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_own_home_directory_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.11 Ensure users' home directories permissions are 750 or more restrictive"
	echo "Result: $users_home_directory_permission_result"
	echo "Command Output:"
	echo ""
	echo -e "$users__home_directory_permission_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.12 Ensure users' dot files are not group or world writable"
	echo "Result: $users_dotFile_not_grp_world_writable_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_dotFile_not_grp_world_writable_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.13 Ensure users' .netrc Files are not group or world accessible"
	echo "Result: $users_netrc_group_accessible_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_netrc_group_accessible_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.14 Ensure no users have .forward files"
	echo "Result: $users_forward_files_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_forward_files_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.15 Ensure no users have .netrc files"
	echo "Result: $users_have_netrc_files_result"
	echo "Command Output:"
	echo ""
	echo -e "$users_have_netrc_files_message"
	echo " "
	echo "================================================================================"
	echo " "
	echo "6.2.16 Ensure no users have .rhosts files"
	echo "Result: $no_users_have_rhosts_result"
	echo "Command Output:"
	echo ""
	echo -e "$no_users_have_rhosts_message"
	echo " "
	echo "================================================================================"




	} > result.txt
}

result